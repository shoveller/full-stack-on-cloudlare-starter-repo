WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:900000

00:00:00.290 --> 00:00:11.500
좋습니다, 이제 애플리케이션의 데이터 레이어를 실제로 구축하기 시작해 봅시다. 약속드린 대로, Cloudflare가 제공하는 내장 D1 데이터베이스를 사용할 것입니다. 이 프로젝트에 정말 좋은 점은 다른 제공업체로 옮겨갈 필요가 없다는 것입니다.

00:00:11.500 --> 00:00:20.670
하지만 만약 여러분이 정말로 확장성이 좋고 클라이언트를 위해 구축하는 것과 같은 아주 진지한 프로젝트를 만들고 있다면, 몇 가지 주의할 점 때문에 이것을 반드시 추천하지는 않을 것입니다.

00:00:21.310 --> 00:00:29.530
제 생각에 D1 데이터베이스는 사이드 프로젝트에 정말 환상적이며, 소규모 프로젝트나 심지어 일부 중규모 프로젝트에도 환상적입니다. 하지만 몇 가지 주의해야 할 사항이 있습니다.

00:00:29.810 --> 00:00:57.449
읽을 수 있는 행 수 측면에서, 그들은 매우 관대한 제안을 합니다. 예를 들어, 월 5달러의 워커 요금제에 가입하면 250억 건의 읽기 작업을 할 수 있고 그 이후에는 사용량에 따라 요금을 지불합니다. 쓰기 작업도 마찬가지입니다. 5천만 건의 쓰기 작업을 할 수 있고 그 이후에는 사용량에 따라 요금을 지불합니다. D1에서 이 정도의 사용량을 기록한다면 정말 대단한 것입니다. 사이드 프로젝트에서 이 정도를 달성하는 것을 본 적이 없습니다. 물론 가능할 수도 있겠지만, 이 시점에서는 꽤 진지한 애플리케이션을 구축하고 있는 것이므로 다른 데이터베이스 제공업체를 선택하는 것이 좋습니다. 따라서 이 임계값 미만이라면 D1을 사용하십시오. 아주 좋은 경험을 할 것입니다.

00:01:01.469 --> 00:01:12.019
여기서 주요 제한 사항은 10기가바이트인 데이터베이스 크기입니다. 대부분의 사이드 프로젝트에서는 데이터베이스 인스턴스당 10기가바이트 제한에 도달하는 것에 대해 걱정할 필요가 없을 것입니다.

00:01:12.099 --> 00:01:42.369
하지만 이것이 문제가 될 수 있는 더 많은 데이터 집약적인 애플리케이션이 있습니다. 그리고 그것이 상황이 정말 까다로워지는 부분입니다. D1 데이터베이스에 대해 많은 사람들이 '그 제한에 대해 걱정하지 않습니다. 왜냐하면 기본적으로 멀티 테넌트 설정을 할 것이고, 이는 각 사용자가 자신만의 데이터베이스를 갖는다는 의미입니다.'라고 말하는 것을 들었습니다. 그리고 Torso라는 회사가 기업 수준 또는 진지한 서비스에서 이러한 방식을 개척했다고 생각합니다. 하지만 본질적으로 그들은 '네, 사용자별로 데이터베이스 인스턴스를 만들 수 있습니다.'라고 말하는 것과 같습니다.

00:01:42.579 --> 00:02:07.839
음, 그것도 완전히 괜찮고 좋습니다. 그렇게 할 수 있습니다. 하지만 제 생각에는 그 설정이 매우 복잡하며, 주요 문제 중 하나는 Cloudflare Worker를 통해 D1 데이터베이스에 연결할 때 Wrangler 설정에서 그것을 명시해야 한다는 것입니다. 따라서 새로운 사용자가 생기고 새로운 데이터베이스를 추가하고 싶다면, 그들을 위해 프로젝트를 새로운 워커로 재배포하거나 배포해야 할 것입니다. 그리고 저는 Cloudflare Worker 생태계 내에서 그것을 어떻게 확장해야 할지 정말 모르겠습니다.

00:02:07.839 --> 00:02:21.189
Cloudflare는 이 사용 사례를 위한 완전히 다른 또 다른 제품을 가지고 있습니다. 그것은 플랫폼용 워커(Workers for Platforms)라고 불리며 몇 가지 다른 기능을 제공합니다. 예를 들어, 기본 월 요금은 25달러이며 추가 사용량에 따라 요금이 부과됩니다.

00:02:21.739 --> 00:02:34.579
기본적으로 워커와 동일한 가격 책정이며, 개발 프로세스도 워커와 동일합니다. 하지만 주요 장점 중 하나는 리소스를 동적으로 생성하고 워커 내에서 해당 리소스에 동적으로 바인딩할 수 있다는 것입니다. 따라서 더 진정한 멀티 테넌트 설정을 구축할 수 있습니다.

00:02:34.579 --> 00:02:50.459
하지만 그렇게 하려면 워커 위에서 구축하는 방법에 대한 기초를 확고히 다져야 합니다. 그리고 이 강좌가 집중할 부분은 바로 그것입니다. 우리는 정말 복잡한 멀티 테넌트 설정에 집중하지 않고, 모든 Cloudflare 서비스를 사용하여 풀스택 애플리케이션을 정말 잘 구축하는 방법에 집중할 것입니다. 그래서 우리는 이것을 고수할 것입니다.

00:02:50.459 --> 00:03:11.489
그래서 이 강좌의 일환으로 D1을 사용할 것입니다. 그리고 D1으로 구축하는 방법을 알아내기 위해 문서를 읽다 보면, fetch 핸들러가 있고 환경 바인딩을 통해 D1 데이터베이스를 가져온 다음 `prepare`라고 말하고 SQL 쿼리를 작성하여 사용자에게 데이터를 가져오는 이런 예제를 보게 될 것입니다. 이 경로는 완전히 괜찮습니다.

00:03:12.809 --> 00:03:23.189
이렇게 쿼리를 작성할 수 있지만, 정말 큰 프로젝트를 구축할 때는 이 프로세스를 더 타입 안전하게 만들고 코드베이스 확장 측면에서 더 확장 가능하게 만드는 데 도움이 되는 일부 도구를 가져오고 싶을 것입니다.

00:03:23.189 --> 00:03:32.961
그리고 그것이 ORM이 등장하는 지점입니다. 원시 SQL 문을 작성하는 대신 코드베이스 내부에 스키마를 정의할 수 있습니다. 즉, 코드베이스 내부에 테이블을 정의할 수 있습니다.

00:03:33.121 --> 00:03:47.001
그런 다음 Drizzle과 같은 ORM을 가져올 수 있습니다. 다른 ORM들도 있지만, Drizzle이 가장 좋은 것 중 하나라고 생각합니다. Drizzle을 사용하면 기본적으로 `database.select().from(users)`와 같이 쿼리를 프로그래밍 방식으로 생성할 수 있으며, 조인 및 필터 등을 사용할 수 있습니다.

00:03:47.001 --> 00:04:09.331
따라서 이것은 정말 타입 안전한 쿼리를 만들고, 쿼리 생성 로직을 기존 SQL 문으로부터 추상화하는 방법과 같습니다. 기존 SQL 문에서는 코드베이스 내에 SQL 문을 작성할 수 있지만 구문 오류가 있거나 테이블 이름이 잘못된 경우와 같습니다. 그러면 갑자기 애플리케이션이 예기치 않게 충돌하고 이유를 찾으려고 애쓰게 되는데, '아, 잘못된 쿼리를 작성했구나. 이건 그냥 문자열일 뿐이니까'라고 생각하게 됩니다.

00:04:09.411 --> 00:04:19.011
그리고 실패 여부를 알 수 있는 유일한 시점은 런타임입니다. 여기서 빌드 시에 정의되지 않은 테이블 이름을 사용하면 오류가 발생합니다.

00:04:19.561 --> 00:04:25.881
그래서 정말 좋습니다. 빌드 프로세스를 훨씬 더 쉽게 만들 수 있습니다. 데이터베이스에서 데이터를 가져올 때 데이터가 타입 안전하게 됩니다.

00:04:26.521 --> 00:04:39.601
이제 문서에서 발견할 수 있는 이 패턴의 또 다른 문제는, 바인딩에서 제공되는 D1 데이터베이스를 Drizzle 메서드에 전달하고 거기에서 쿼리를 작성할 수 있는 Drizzle 데이터베이스를 갖게 된다는 것입니다. 하지만 여기서 여러분이 알아차릴 것(아니, 알아차리지 못할 수도 있지만, 더 큰 프로젝트를 구축하면서 알게 될 것)은 수많은 다양한 API 엔드포인트와 서버 함수 등이 생겨날 것이라는 점입니다.

00:04:41.681 --> 00:05:01.310
그리고 이 작업은 매우, 매우 반복적일 것입니다. 동일한 데이터베이스 인스턴스를 Drizzle 메서드에 계속 전달하고, 애플리케이션 코드 내에서 쿼리를 생성하게 될 것입니다. 소규모 프로젝트에는 괜찮지만,

00:05:03.030 --> 00:05:21.330
프로젝트가 커질수록 동일한 쿼리를 계속해서 다시 작성하게 된다는 것을 알게 될 것입니다. 그리고 이것이 모노레포 설정이 도입되는 지점입니다. 우리는 쿼리를 추상화하거나 다른 패키지로 이동시켜 정의할 수 있습니다. 예를 들어, 이 쿼리는 이 사용 사례를 위한 것이고 프로젝트 전체에서 사용할 수 있다고 말할 수 있습니다.

00:05:21.410 --> 00:05:50.730
그래서 Data Ops라는 패키지가 있는 것과 같은 방식일 것입니다. 지금 우리 프로젝트에 있으며, 우리 모노레포에 있습니다. 그리고 Drizzle ORM을 사용하여 작성된 여러 SQL 쿼리가 그 안에 정의되어 있을 것이고, 그 쿼리들은 우리 애플리케이션 전체에서 가져와 사용될 것입니다. 이 프로젝트에는 두 개의 애플리케이션만 있을 것입니다. 하지만 서비스가 성장하고 사용 사례가 더 정교해짐에 따라, 더 많은 배포 가능한 독립적인 애플리케이션을 갖게 될 수도 있습니다. 그러면 동일한 쿼리를 가져와 사용할 수 있으므로 코드베이스 전체에 중복된 코드가 많이 생기지 않을 것입니다.

00:05:51.210 --> 00:06:03.290
제가 따르고 싶은 또 다른 패턴은, 여기를 보면 이 Drizzle 인스턴스가 D1 데이터베이스를 가져오고 있다는 것입니다. 하지만 다른 데이터베이스 제공업체에 연결하면, 이 객체를 생성하는 방식이 다릅니다.

00:06:03.450 --> 00:06:11.352
Neon의 경우, 쿼리 URL을 함께 전달합니다. Supabase는 다른 ORM, 예를 들어 다른 것을 사용하는 또 다른 시나리오와 같습니다. 이 경우 postgresjs입니다. 해당 URL을 전달하고, PlanetScale은 Drizzle ORM의 일부로 PlanetScale Serverless를 사용하기 때문에 약간 다릅니다.

00:06:11.921 --> 00:06:30.339
그런 다음 호스트, 사용자 이름, 암호와 같은 개별적인 정보를 전달합니다. 따라서 애플리케이션 레이어에서 코드 전체의 수많은 다른 곳에서 Drizzle을 이런 식으로 정의하고, 데이터베이스 제공업체를 교체하면 갑자기 전체 코드베이스를 검토해야 할 것입니다. Drizzle에 대한 실제 import 문을 업데이트해야 할 것이고, 전체 코드베이스에서 Drizzle이 인스턴스화되는 방식을 업데이트해야 할 것입니다.

00:06:50.119 --> 00:06:58.159
이는 다른 데이터베이스로 마이그레이션하는 것을 매우 어렵게 만들 것입니다. 그리고 ORM이 훌륭하다고 생각하는 이유 중 하나는 이론적으로 더 쉽게 다른 데이터베이스로 마이그레이션할 수 있기 때문입니다.

00:06:58.159 --> 00:07:04.013
그래서 저는 이 모든 문제를 해결할 수 있는 모노레포 설정을 보여드릴 것입니다. 이제 바로 시작하겠습니다.

00:07:04.064 --> 00:07:09.064
좋습니다. 프로젝트로 돌아와서 `packages` 폴더의 `Data Ops`로 들어가면,

00:07:09.064 --> 00:07:15.744
본질적으로 이것은 패키지이며, 이 패키지에는 다양한 서비스 또는 다양한 앱에서 공유되는 코드가 포함될 것입니다.

00:07:15.744 --> 00:07:33.784
따라서 Data Ops 패키지에는 데이터베이스 쿼리, Zod 스키마, 그리고 다양한 서비스에서 공유될 수 있는 좀 더 일반적인 로직과 같은 정보가 포함될 것입니다. 그리고 이것들은 우리의 사용자 애플리케이션(프론트엔드 애플리케이션)과 우리가 많은 시간을 할애하여 구축할 데이터 서비스에서 사용될 것입니다.

00:07:33.784 --> 00:07:47.924
이제 애플리케이션이 확장됨에 따라 다양한 서비스, 다양한 배포 가능 항목을 구축하는 시나리오가 있을 수 있으며, 모든 이러한 다양한 애플리케이션 간에 일반 코드를 쉽게 공유할 수 있다는 것은 정말 좋습니다. 그래서 지금부터 따를 프로세스입니다.

00:07:48.324 --> 00:07:57.164
그리고 Cloudflare에서 데이터베이스를 만들고, 데이터와 테이블을 만들기 전에, 구조를 잠시 살펴보겠습니다.

00:07:57.164 --> 00:08:08.614
이것은 pnpm 워크스페이스와 같은 패키지이며, `package.json` 파일 내부에 정의된 일부 스크립트가 있습니다. 그리고 이 스크립트의 대부분은 Drizzle과 관련되어 있습니다.

00:08:08.814 --> 00:08:16.834
그리고 Drizzle 위에 구축하거나 Drizzle을 사용하는 전체 프로세스에 익숙하지 않다면, 제가 링크를 걸어둘 꽤 괜찮은 비디오가 있습니다. 그들의 문서도 꽤 좋습니다.

00:08:16.834 --> 00:08:34.514
하지만 스키마가 존재한다면 일부 명령, 특히 Drizzle Kit Poll을 실행하여 해당 테이블을 가져오고 해당 테이블을 나타내는 TypeScript 파일을 많이 생성할 수 있습니다. 이 파일들은 스키마라고 불리며, 이 스키마를 사용하여 쿼리를 생성할 수 있습니다.

00:08:34.514 --> 00:08:44.184
그리고 `migrate` 및 `generate`와 같이 이 강좌에서는 많이 사용하지 않을 다른 것들도 있습니다. Studio는 대화형 쿼리 환경을 제공합니다. 그래서 지금 우리가 걱정할 것들은 이런 것들입니다.

00:08:44.314 --> 00:09:09.784
그리고 이것을 가능하게 하려면 Drizzle 설정으로 이동해야 합니다. 이것은 기본적으로 '데이터베이스에 인증하는 방법은 이렇다'고 말해줍니다. 그리고 실제로 데이터베이스에서 정보를 가져와 TypeScript 파일을 생성하면, 그 파일들은 어디로 갈까요? 그것이 이 `out` 명령이 하는 일입니다. 기본적으로 `src` 폴더 안에 Drizzle 스키마를 출력하고, 코드베이스 내부에 파일을 생성할 것이라고 말합니다. 그래서,

00:09:09.974 --> 00:09:24.994
이제 그것을 살펴볼 것입니다. 그리고 Cloudflare 계정 ID, 데이터베이스 ID, Cloudflare D1 토큰과 같은 것들이 있다는 것을 알게 될 것입니다. 그래서 지금 바로 이것을 생성하는 과정을 거칠 것입니다. 먼저 테이블을 생성한 다음, Drizzle과 함께 구성하고 작업할 것입니다. 거기서부터 진행하겠습니다.

00:09:25.154 --> 00:09:36.392
Cloudflare 대시보드로 이동하여 스토리지 및 데이터베이스 섹션으로 이동한 다음 D1 SQL 데이터베이스로 이동하면, 현재 생성된 데이터베이스가 없다는 것을 알 수 있습니다.

00:09:36.392 --> 00:10:05.742
그래서 데이터베이스를 생성할 것입니다. 이 프로젝트의 이름은 'Smart Links'로 하고, 프로젝트 이름 뒤에 'stage'를 붙일 것입니다. 여기에 'stage'를 붙이는 이유는 이 프로젝트의 막바지에 애플리케이션의 여러 환경을 생성하는 방법을 보여줄 것이기 때문입니다. 그래서 테스트 및 개발용 환경을 하나 가질 수 있고, 사용자에게 공개되는 프로덕션 버전으로 옮기기 전에 테스트할 수 있는 아이디어를 구축할 수 있습니다.

00:10:05.742 --> 00:10:13.482
따라서 지금 개발하고 있는 모든 것은 '대시 스테이지'와 같을 것이고, 나중에 프로덕션용으로 하나를 만들 것입니다. 그래서 생성 버튼을 누를 수 있습니다.

00:10:13.496 --> 00:10:24.754
이제 그것이 하는 일은 데이터베이스를 제공하는 것입니다. 설정을 빠르게 살펴보겠습니다. 하지만 Drizzle과 함께 작동하도록 하려면 몇 가지 다른 것들이 필요합니다. 우리 계정 ID가 필요합니다.

00:10:24.754 --> 00:10:40.034
계정 ID는 두 곳에서 찾을 수 있습니다. 하나는 URL의 이 첫 번째 섹션과 같은 곳에서 찾을 수 있지만, 거기서 가져오는 것은 좀 번거롭습니다. 그래서 워커로 가서 계정 ID와 같은 섹션이 있는 곳을 찾을 수 있습니다. 이제 그것을 복사하겠습니다.

00:10:40.934 --> 00:11:03.034
먼저 Data Ops 패키지의 루트에 `.env`라는 파일을 만들고 여기에 붙여넣을 것입니다. 이 파일은 항상 `.gitignore`에 포함시켜 실수로 GitHub에 푸시하지 않도록 해야 합니다. 그런 다음 `Cloudflare account ID`를 이 계정 ID로 설정할 것입니다.

00:11:03.552 --> 00:11:19.192
Cloudflare 데이터베이스에 대해서도 마찬가지로 할 것입니다. 그래서 `cloudflare D1 database`라고 말할 것입니다. 다시 스토리지 및 데이터베이스의 D1 SQL 데이터베이스로 돌아가서, 그것을 클릭하고 데이터베이스 링크를 복사하겠습니다.

00:11:19.832 --> 00:11:27.652
이제 이 모든 단계를 알아두세요. Wrangler CLI를 통해서도 데이터베이스를 생성하고 관리할 수 있습니다. 저는 단지 대시보드에도 익숙해지도록 하고 싶습니다.

00:11:27.972 --> 00:11:36.352
이제 마지막으로 필요한 것은 Cloudflare D1 토큰입니다. 이것은 문서화가 덜 되어 있는데, 그래서 제가 이 과정을 가치 있게 생각하는 이유 중 하나입니다. 이 과정을 보시면 알 수 있듯이, Cloudflare는 API를 통해 리소스를 관리할 수 있는 API 토큰을 제공합니다.

00:11:36.352 --> 00:11:47.632
그리고 Drizzle Kit도 Cloudflare 인증에 사용하고 있는 것이 바로 이것입니다. 그래서,

00:11:47.892 --> 00:12:02.302
왼쪽 하단의 '계정 관리'로 이동할 수 있습니다. '계정 API'로 이동한 다음 토큰 생성을 할 것입니다. 미리 만들어진 것들이 많이 있지만, 저는 보통 이 템플릿을 사용하지 않고 '맞춤 토큰'을 만들 것입니다.

00:12:02.542 --> 00:12:13.542
시작하기를 누르고 이 토큰의 이름을 'Smart Links DB 토큰'으로 지정하겠습니다. 이 토큰은 단 한 번만 볼 수 있으니, 어딘가에 저장하고 안전하게 보관하세요.

00:12:13.952 --> 00:12:25.202
다음으로 D1을 검색할 것입니다. D1을 입력하면 가장 아래에 있습니다. 이것은 D1에 대한 접근 권한을 부여할 것이며, 우리는 편집 권한을 부여할 것입니다. 그래서 쓰기 및 업데이트 작업도 할 수 있습니다.

00:12:25.602 --> 00:12:35.342
그리고 요약으로 계속해서 토큰을 생성할 것입니다. 이 토큰은 나중에 삭제할 것이므로 훔치려고 하지 마세요. 이 토큰은 사라질 것입니다.

00:12:36.212 --> 00:12:40.932
이제 Cloudflare D1 토큰으로 와서 여기에 추가하겠습니다.

00:12:41.452 --> 00:12:52.515
저장하고, `packages`로 `cd`했는지 확인하세요. 그래서 `cd packages`입니다. 그리고 `data Ops`라고 말할 것입니다. 이제 Data Ops의 루트 레벨에 있습니다.

00:12:52.755 --> 00:12:58.195
우리가 하고 싶은 일은 몇 가지를 가져오고, 기본적으로 모든 것이 제대로 작동하는지 확인하고 싶은 것입니다.

00:12:58.355 --> 00:13:02.295
여기서 보시다시피, `package.json` 파일이 있습니다.

00:13:02.725 --> 00:13:08.675
아니요, 죄송합니다. 잘못된 섹션입니다. Data Ops 소스에는 `package.json` 파일이 있습니다.

00:13:08.995 --> 00:13:17.965
그리고 `pull` 스크립트가 있습니다. 이것은 현재 아무것도 존재하지 않는 D1 데이터베이스 내부에 존재하는 모든 테이블을 가져와 코드베이스에 넣을 것입니다.

00:13:17.965 --> 00:13:21.325
그래서 저는 `pnpm run poll`이라고 말할 것입니다.

00:13:22.722 --> 00:13:24.422
잘못된 단어입니다. `pnpm run`.

00:13:25.509 --> 00:13:39.959
좋습니다. 이제 이런 것을 보게 될 것입니다. 모든 테이블을 가져오고 다른 마이그레이션을 완료한 다음, 결국 프로젝트 내부에 `Drizzle out` 폴더가 생길 것입니다. 그리고 그 `Drizzle out` 폴더에는 스키마 파일이 있을 것입니다. 그리고 스포일러 경고입니다. 아직 테이블을 생성하지 않았기 때문에 스키마가 없습니다.

00:13:43.349 --> 00:13:44.982
하지만 지금 바로 그것을 진행할 것입니다.

00:13:45.145 --> 00:14:07.272
Cloudflare UI로 돌아가서 데이터베이스 섹션으로 돌아가 Smart Links 스테이지 테이블을 클릭해 봅시다. 이것은 Cloudflare의 비교적 새로운 기능입니다. UI가 조금 바뀔 수도 있지만, 데이터 탐색을 클릭하면 테이블을 생성하고 쿼리를 작성하는 등 우리만의 대화형 쿼리 환경을 제공합니다.

00:14:07.272 --> 00:14:17.972
이제 몇 가지 테이블을 생성할 것입니다. 첫 번째로 생성할 테이블은 `links`라고 부를 것입니다. 이것을 직접 입력하는 것에 대해 걱정하지 마세요. 붙여넣을 수 있도록 할 것입니다. 비디오 하단에 넣어둘 테니, 여러분은 붙여넣을 수 있을 것입니다.

00:14:17.972 --> 00:14:30.772
그래서 `links` 테이블을 생성할 것입니다. 이 `links` 테이블에는 링크에 대한 ID, 계정 ID 목적지 등 유용한 다양한 정보가 포함될 것입니다. 이제 그것을 실행할 수 있습니다.

00:14:31.187 --> 00:14:51.465
또한 `Link Clicks`라는 테이블을 생성할 것입니다. 이 테이블은 분석을 담당할 것입니다. 즉, 링크별, 지역별 클릭 수 등 대시보드 관련 모든 정보를 보여줄 수 있는 테이블입니다. 이제 그것을 실행할 수 있습니다.

00:14:51.576 --> 00:14:56.355
그리고 우리는 몇 가지 다른 인덱스도 생성할 것입니다.

00:14:56.515 --> 00:15:12.965
그래서 이 프로젝트에는 사실 필요 없을 수도 있습니다. 하지만 테이블에 인덱스를 생성하면 기본적으로 각 테이블에 대한 데이터 구조를 만들어 읽기 및 쓰기 성능을 향상시킵니다. 정확히 말하면 이 경우 읽기는 더 성능이 좋고, 쓰기는 덜 성능이 좋을 것입니다.

00:15:12.965 --> 00:15:30.155
하지만 계정별로 데이터가 세분화되어 있고 모든 쿼리가 계정에 대한 모든 데이터를 찾으려고 필터링하는 시나리오가 있다면, 계정을 기반으로 인덱싱하는 것이 좋습니다. 그러면 쿼리가 해당 계정을 매우 빠르게 격리한 다음 데이터를 스캔할 수 있습니다.

00:15:30.515 --> 00:15:40.595
스키마 관리 방법, 효율적인 쿼리 작성 방법, 인덱스에 대해 더 자세히 알고 싶다면, 또는 데이터 분야에 경험이 많지 않다면,

00:15:40.995 --> 00:15:58.235
PlanetScale은 이 비디오 하단에 링크를 걸어둘 강의가 있는데, 그들은 스키마와 데이터 유형, 효율적인 쿼리 작성 방법, 인덱싱 방법 등에 대해 꽤 높은 수준으로 다루면서도 상대적으로 깊이 있게 설명합니다. 솔직히 이것은 시중에서 구할 수 있는 최고의 무료 SQL 리소스 중 하나라고 생각합니다.

00:15:58.235 --> 00:16:11.352
그래서 SQLite에도 적용됩니다. 이러한 개념들은 다른 데이터베이스들에서도 대체로 동일합니다. 그러니 '아, 나는 PlanetScale을 사용하지 않는데'라고 생각하지 마세요. 이 개념들은 단 하나의 데이터베이스 유형이나 제공업체에만 국한되지 않고 확장됩니다.

00:16:11.921 --> 00:16:17.449
좋습니다. 다시 여기로 돌아오겠습니다. 이 인덱스들을 실행하고, 이 모든 것들을 실행하겠습니다.

00:16:17.599 --> 00:16:25.675
그리고 마지막으로 생성할 테이블은 `destination evaluations`입니다. 바로 이 테이블입니다.

00:16:26.315 --> 00:16:32.035
기본적으로 우리 AI가 실행하는 평가들을 추적하는 테이블입니다.

00:16:32.035 --> 00:16:49.634
그래서 우리 AI는 프로그램적으로 이동하여 다양한 목적지 링크를 찾을 것입니다. 페이지를 로드하고, 페이지 콘텐츠를 살펴본 다음, '이 제품이 품절되었는지, 이 페이지를 더 이상 사용할 수 없는지'와 같은 정보를 알려줄 것입니다. 꽤 스마트한 AI 시스템이 될 것이며, 그 과정에 대한 메타데이터를 저장해야 할 것입니다. 이 테이블이 바로 그 역할을 할 것입니다.

00:16:49.634 --> 00:17:04.195
이 테이블들을 정말 빠르게 살펴보고 있다는 것을 알고 있습니다. 더 진행할수록 훨씬 더 이해가 잘 될 것입니다. 하지만 이 비디오 섹션의 주요 목적은 테이블을 생성하는 것입니다. 그렇게 해야 우리 애플리케이션에서 해당 테이블을 실제로 사용할 수 있습니다.

00:17:04.836 --> 00:17:09.396
이제 여기서 제가 강조하고 싶은 주요 요점은 우리가 테이블을 모두 생성했다는 것입니다.

00:17:09.876 --> 00:17:32.118
이제 우리의 레포로 돌아가서, 애플리케이션이 아닌 Data Ops 패키지에 있는지 확인한 다음, `pnpm run Poll`을 실행하면 Drizzle이 방금 Cloudflare D1 데이터베이스에서 생성한 테이블을 기반으로 모든 스키마를 동적으로 생성할 것입니다.

00:17:32.118 --> 00:17:41.848
그래서 링크 테이블, 링크 클릭 테이블, 목적지 평가 테이블이 있는 것을 볼 수 있습니다. 이것들이 우리가 생성한 세 개의 테이블입니다.

00:17:41.848 --> 00:17:49.281
그리고 이제 이 스키마를 사용하여 실제로 테이블에 데이터를 삽입하거나 테이블에서 데이터를 읽는 쿼리를 작성할 수 있습니다.