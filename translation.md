WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:900000

[00:00 ~ 00:15]
네, 이제 모노레포의 패키지 내에서 이 링크들을 구축하고 TRPC 라우트에 연결하는 과정을 거쳤으니, 이 프로젝트에서 더 정교하고 복잡한 작업으로 넘어가기 전에 모든 CRUD 작업을 마무리하는 과정을 진행해 보겠습니다.

[00:15 ~ 00:35]
여기서 보시면, 방금 생성한 링크 생성 함수가 있습니다. 또한 생성된 모든 링크가 표시되는 링크 데이터 테이블도 있습니다. 여기서 짧은 링크로 사용할 수 있는 실제 링크를 볼 수 있고, 복사할 수 있습니다. 또한 그 링크를 클릭하면 링크 페이지로 이동할 수 있습니다.

[00:35 ~ 01:08]
이제 이 링크 페이지에는 또한 여러 CRUD 작업이 있습니다. 이름을 편집할 수 있습니다. 따라서 새 이름을 입력할 수 있습니다. 기본 대상 URL을 편집할 수 있습니다. 따라서 이것이 라우팅될 곳을 변경할 경우, 추가적으로 GEO 라우팅을 활성화하거나 비활성화할 수 있습니다. 따라서 알바니아의 모든 사람이 별도의 링크로 라우팅되도록 하려면 여기서 제어할 수 있습니다. 그러나 특정 링크에 대해 GEO 라우팅을 끌 수도 있습니다. 이것들이 애플리케이션을 구동할 CRUD 작업입니다.

[01:08 ~ 01:18]
그리고 이것들이 완료되면 실제로 데이터베이스에 데이터를 가져올 수 있고, 그 위에 백엔드 시스템을 구축할 수 있습니다. 그게 정말 재미있는 부분입니다. 그럼 계속 진행해 봅시다.

[01:18 ~ 01:23]
가장 먼저 하고 싶은 것은 이 데이터 테이블에 실제 실시간 데이터가 표시되도록 하는 것입니다.

[01:23 ~ 01:41]
따라서 패키지로 돌아가면, 새 쿼리를 생성하고 싶을 것입니다. 그리고 이 쿼리는 Get Links라고 불릴 것입니다. 그리고 시간이 부족해서 이것은 타이핑하기에 꽤 많기 때문에 여기에 붙여넣은 다음 우리가 하고 있는 작업을 살펴보겠습니다. 자,

[01:41 ~ 02:00]
이 모든 것들이 가져왔는지 확인하십시오. 기본적으로 이 쿼리가 하는 일은 모든 단일 쿼리에 대해 자세히 이야기할 필요는 없지만, 저는 이 쿼리 추상화, 즉 메서드 뒤에 넣는 방법이 얼마나 강력할 수 있는지 보여주고 싶습니다.

[02:00 ~ 02:22]
따라서 기본적으로 우리가 하고 있는 것은 동일한 규칙을 따르는 것입니다. 특정 계정의 모든 링크를 보고 싶기 때문에 계정 ID가 있습니다. 그리고 created before라는 선택적 속성이 있습니다. 이것이 하는 일은 누군가가 수천 개의 링크를 가지고 있다면, 우리는 이 날짜 이전에 생성된 15개의 링크를 보여주도록 기본적으로 말할 수 있는 페이지네이션을 구현할 수 있다는 것입니다. 그런 다음 마지막 날짜를 가져와서 이 날짜 이전에 생성된 링크를 말합니다.

[02:22 ~ 02:30]
따라서 이것은 제한 숫자와 created before가 있는 페이지네이션을 구현하는 매우 간단한 방법입니다. 이제 우리가 하는 일은 기본적으로 이러한 조건을 갖는 것입니다.

[02:30 ~ 02:56]
따라서 이것들은 쿼리의 필터가 될 것이고, 기본값이 있을 것입니다. 따라서 항상 계정 ID로 필터링할 것입니다. 그리고 created before가 정의되면, 더 큰 쿼리를 푸시할 것입니다. 따라서 이것은 created라는 열에서, 즉 해당 링크의 생성 시간에서 created before 날짜보다 큰 모든 것을 보여주라고 말하는 것입니다.

[02:56 ~ 03:21]
그런 다음 매우 간단한 선택입니다. 따라서 링크 ID, 대상 배열, 대상 객체 또는 JSON 객체, 생성 시간 및 링크 이름을 선택할 것입니다. 이것은 링크에서 올 것이고, 여기서 우리의 조건인 계정 ID는 해당 계정 ID이며 해당 생성 날짜 이전입니다. 그런 다음 생성 날짜별로 정렬하여 정렬할 것입니다. 그런 다음 25개로 제한할 것입니다. 따라서 항상 25개만 반환합니다.

[03:21 ~ 03:36]
그리고 이것이 바로 이 데이터 테이블을 구동할 것입니다. 따라서 여기에 새 쿼리를 추가할 때마다 데이터 옵스 패키지에 있는지 확인해야 합니다. 그래서 저는 패키지 데이터 옵스라고 말한 다음 pnpm run build라고 말할 것입니다.

[03:36 ~ 03:51]
그러면 프로젝트가 빌드되고, 링크 가져오기가 해당 디스크 폴더로 덤프된 다음 다른 애플리케이션에서 사용할 수 있게 됩니다. 이제 우리가 하고 싶은 것은 사용자 애플리케이션으로 이동하는 것입니다. 그리고 UI에서 백엔드로 작업하는 것이 가장 좋을 것 같습니다.

[03:51 ~ 04:13]
따라서 소스로 이동하여 라우트로 이동하면, 프런트엔드에서 라우트 앱 auth로 이동한 다음 링크로 이동할 것입니다. 이것이 우리의 링크 페이지입니다. 이제 이 링크 페이지에는 링크 목록에서 데이터를 미리 가져오는 로더가 있습니다. 이것은 기본적으로 바로 이 데이터입니다.

[04:13 ~ 04:47]
그리고 우리가 할 수 있는 것은 기본적으로. 그래서 그것이 하는 일은 속도입니다. 데이터를 전달하고 있습니다. 해당 링크 목록에서 데이터를 가져오고 있으며, created before 시간만 필요하기 때문에 입력을 전달하지 않습니다. 그리고 페이지의 첫 번째 로드에서는 created before를 가져올 필요가 없습니다. 가장 최근 25개의 링크를 가져올 것이기 때문입니다. 따라서 여기로 오면 suspense 쿼리를 사용하고 있음을 알 수 있습니다.

[04:47 ~ 05:22]
따라서 이것이 루트 구성 요소에서 해당 데이터에 실제로 액세스하는 곳입니다. 그리고 이 링크가 정확히 어디에 사용되는지 볼 수 있습니다. 그래서 저는 링크 점을 말할 것입니다. 기본적으로 이 링크 데이터를 가져오고, 코드의 더 깊은 곳으로 내려가면 실제로 이 테이블이 있다는 것을 알 수 있습니다. 그리고 이 테이블은. 이것은 tan stack 테이블입니다. 우리는 이것에 대해 너무 깊이 파고들지 않을 것입니다. 하지만 정렬하고, 항목을 이동하고, 즉시 사용할 수 있는 많은 기능을 원하는 복잡한 테이블을 구축한다면, tanstack react table은 엄청나게 좋은 패키지입니다.

[05:22 ~ 05:53]
따라서 우리는 그것에 대해 너무 깊이 들어가지 않을 것입니다. 하지만 우리가 일부 열을 정의할 수 있다는 것을 아십시오. 해당 열의 스타일을 지정하고, 버튼을 넣을 수 있습니다. 이것은 복사 버튼이 있는 특정 버튼이며, 복사하면 클립보드로 복사됩니다. 따라서 여기서 우리가 할 수 있는 일은 정말 멋집니다. 하지만 우리가 더 아래로 내려가서 데이터가 링크라고 기본적으로 말하면, 이것은 테이블을 가져오고, 행을 가져오고, 기본적으로 여기서 테이블을 반복하고 생성하기 시작할 것입니다. 따라서 무슨 일이 일어나고 있는지 알 수 있습니다.

[05:53 ~ 06:12]
따라서 기본적으로 우리가 해야 할 일은 백엔드에서 방금 생성한 쿼리를 채우거나 실제로 연결하는 것입니다. 이 링크 목록, 링크 목록 메서드입니다. 따라서 그것을 명령 클릭하면 작업자 TRPC 라우트, 링크로 이동할 것입니다. 왼쪽 사이드바에서 탐색할 수도 있습니다. 그것이 당신이 하고 싶은 일이라면 말이죠.

[06:12 ~ 06:37]
따라서 이 특정 프로시저가 선택적 오프셋을 가져온다는 것을 알 수 있습니다. 오프셋은 숫자이며 실제 날짜, 시간이며, 그런 다음 무엇을 할 것인가는 이 큰 바보 같은 무작위 링크와 더미 데이터의 더미 데이터를 반환할 것이라는 것입니다. 그래서 저는 계속해서 이 모든 것을 삭제하고 여기로 돌아갈 것입니다.

[06:37 ~ 07:17]
유형 오류가 발생해야 합니다. 그리고 제가 할 일은 기본적으로 await라고 말할 것입니다. Get links는 우리가 정의한 메서드이며, 이것은 여기 쿼리에서 와야 합니다. 그래서 우리는 우리로 이동할 수 있습니다. 먼저 이 링크 목록을 삭제하고, 그런 다음 get get links라고 말할 것입니다. 좋아요, 이제 패키지에 정의한 이 get links 메서드가 가져왔으니, 여기로 와서 이것이 계정 ID와 created before 시간을 가져올 것이라는 것을 알 수 있습니다.

[07:17 ~ 07:44]
따라서 우리가 하고 싶은 것은 컨텍스트를 가져오고 싶고, TRPC 쿼리에 대한 쿼리 내에서 입력을 가져오고 싶다는 것입니다. 그리고 우리 사용 사례에 대한 계정 ID는 user info.id가 될 것입니다. 지금은 더미 데이터입니다. 지금은 이것에 대해 자세히 알아볼 것입니다. 따라서 이 과정의 이 부분을 위해, 이것이 어디에서 오는지, 그리고 왜 나중에 알게 될 것이라는 것만 아십시오.

[07:44 ~ 08:26]
그리고 우리는 또한 선택적 오프셋이 있는 입력을 전달할 것입니다. 그리고 우리는 이것을 오프셋이라고 부릅니다. 왜냐하면 이것이 페이지네이션을 추가할 때 전달될 실제 날짜 시간으로 의도되었기 때문입니다. 그리고 여기서 우리가 해야 할 유일한 일은 이것이 숫자이기 때문에 그 녀석을 문자열로 캐스팅해야 한다는 것입니다. 좋아요, 여기서 우리는 input offset to string을 가지고 있습니다.

[08:26 ~ 08:41]
따라서 우리는 기본적으로 이 프로시저가 지정된 이전 날짜와 함께 호출될 때마다 여기에 선택되고 그렇지 않으면 undefined가 전달될 것이라고 말할 수 있습니다. 이제 이 엔드포인트를 성공적으로 호출할 수 있습니다. 그리고 우리가 사용자 애플리케이션을 실행하고 여기로 돌아가면,

[08:41 ~ 09:10]
이 링크 페이지가 로드될 때, 모든 것을 올바르게 했다면, 우리가 생성한 하나의 링크로 이 테이블이 채워지는 것을 볼 수 있어야 합니다. 따라서 로딩에는 시간이 조금 걸릴 것입니다. 그리고 이것은 우리가 실험적인 개발 모드를 사용하고 있기 때문입니다. Cloudflare가 이 기능을 조금 더 구축함에 따라 이것이 더 빨라질 것이라고 생각합니다. 따라서 여기에서 우리가 생성한 두 개의 링크를 볼 수 있습니다. Optimistic Parrot과 Product one을 생성했습니다. 그리고 이 과정을 거쳐 Product Three라고 말하고 다른 임의의 링크를 제공하고 생성을 누르면 해당 링크로 돌아가면 이제 세 개가 있음을 볼 수 있습니다. 그리고 클릭할 수 있습니다. 그리고 이 페이지의 실제 데이터는 여전히 더미 데이터이지만,

[09:10 ~ 09:30]
이제 우리는 이 데이터 테이블을 성공적으로 채웠습니다. 그럼 실제로 여기서 모든 CRUD 작업을 구축하는 과정을 진행해 봅시다. 그리고 시간 관계상 이것은 정말, 정말 빨리 진행할 것입니다. 왜냐하면 저는 이 UI 설정을 확고히 하는 것이 정말 중요하다고 생각하지 않기 때문입니다. 저는 실제로 백엔드의 실제 데이터 작업으로 넘어가고 싶습니다. 왜냐하면 거기서 우리의 학습이 가속화될 것이기 때문입니다.

[09:30 ~ 09:39]
좋아요, 데이터 옵스 패키지로 돌아가서 이 쿼리로 이동하면 지금 당장 필요할 다른 많은 쿼리를 덤프할 것입니다.

[09:39 ~ 09:53]
따라서 링크 이름을 업데이트하는 쿼리가 필요합니다. 따라서 이것은 데이터베이스를 가져오고, 링크 테이블로 이동하여 링크 ID가 링크 ID와 같은 경우 이름과 업데이트 시간을 업데이트할 것입니다.

[09:53 ~ 10:05]
또한 Get Link라는 메서드를 생성할 것입니다. 이것은 페이지가 로드될 때 이 페이지의 기본 링크 정보를 제공할 것입니다. 이름, 대상 URL 및 모든 재미있는 것들처럼 말이죠. 그래서

[10:05 ~ 10:18]
여기서 우리가 가지고 있는 것은 기본적으로 주어진 링크 ID를 기반으로 전체 행을 선택하는 것과 같습니다. 그리고 여기서도 스키마를 사용하고 있는 것 같습니다. 따라서 이것을 zodlink 스키마에서 가져올 것이고, 이것이 실제 링크에 대한 스키마라는 것을 알 수 있습니다.

[10:18 ~ 10:30]
따라서 링크 ID, 계정 ID 이름, 대상, 생성 및 업데이트. 꽤 간단한 스키마입니다. 그래서 우리는 그것을 저장할 수 있고, 여기로 돌아갈 수 있습니다. 우리는 또한 링크 대상을 업데이트하고 싶을 것입니다.

[10:30 ~ 11:00]
따라서 링크가 라우팅되는 기본 대상, 즉 이 것이 될 것입니다. 그리고 우리가 링크 수준에서 구성하는 추가적인 지리적 라우팅과 같은 것도 이 호출에 의해 구동될 것입니다. 따라서 다른 함수를 만들 수 있습니다. Update link destinations라는 다른 함수를 만들 수 있습니다. 그런 다음 이 유형을 가져올 것입니다. 대상 유형입니다. 여기서 보면 이 객체가 될 것이고, 이것은 실제로는, 이것은 실제로는, 당신은 이것을 보고 이것이 다소 복잡한 유형이라고 생각할 수 있습니다. 하지만

[11:00 ~ 11:41]
여기서 우리가 가지고 있는 것은 기본적으로 기본 키를 가져오는 ZOD 객체이며, 이것은 기본 URL이며, 다른 키-값 쌍을 가질 수 있습니다. 그리고 키-값 쌍은 기본적으로 국가 ID와 대상 URL입니다. 따라서 우리는 항상 기본 URL을 갖기 위해 object.default를 호출할 수 있고, 거기에 있는 다른 모든 키는 기본적으로 위치 기반 라우팅 구성과 같은 이 흥미로운 유형을 정의했습니다. 좋아요, 이제 링크로 돌아가서 우리가 할 일은

[11:41 ~ 12:00]
이 대상 유형을 가져와서 파싱하고 데이터베이스에 넣기 전에 완전히 안전한지 확인하는 것을 볼 수 있습니다. 그리고 이것은 제가 따르기를 좋아하는 패턴입니다. 메서드에 데이터를 넣을 때 유형 힌트에 도움이 되도록 정의된 유형이 있습니다. 하지만 또한 파싱을 하는 것을 좋아합니다. 왜냐하면 데이터가 실제로 데이터베이스에 들어가기 전에 애플리케이션 런타임에서 오류를 발생시키는 것을 선호하기 때문입니다.

[12:00 ~ 12:29]
그런 오류를 발생시키는 것이 이것을 하지 않고 데이터베이스에 잘못된 애플리케이션 코드, 잘못된 데이터가 들어갈 가능성을 갖는 것보다 낫습니다. 따라서 이것은 제가 쿼리를 구축할 때 좋아하는 추가 보호 계층입니다. 업데이트해야 할 민감한 유형이 있다면 사전에 약간의 사전 처리를 하는 것을 좋아합니다. 네, 이것은 이것을 구동하는 데 필요한 모든 것이어야 합니다. 이것을 업데이트할 수 있을 것입니다.

[12:29 ~ 12:42]
지리적 라우팅 등을 활성화할 수 있을 것이고, 국가가 라우팅될 곳을 넣을 수도 있을 것입니다. 따라서 이것이 저장되었는지 확인하십시오. 그런 다음 npm run build를 실행할 것입니다. 이 녀석을 빌드할 것입니다.

[12:42 ~ 12:53]
이것은 우리가 방금 정의한 이 모든 쿼리가 우리 패키지에서 사용할 수 있도록 할 것입니다. 그런 다음 애플리케이션으로 이동할 것입니다. 그리고 여기서 우리가 할 수 있는 것은 우리 UI로 이동하여 앱으로 이동하는 것입니다. 그리고 우리는 링크, 링크 ID를 가지고 있습니다.

[12:53 ~ 13:26]
그리고 이것이 이 ID의 동적 변수가 가져와질 곳입니다. 그리고 여기서 주목할 점은 이 구성 요소가 로드될 때입니다. 따라서 이 페이지가 처음 로드될 때, 우리는 gitlink 데이터를 미리 가져올 것이고, 그 gitlink 데이터는 이 전체 구성 요소에서 사용될 것입니다. 따라서 우리는 너무 깊이 들어가지 않을 것입니다. 그것이 어디에 사용되는지 살펴보실 수 있습니다. 하지만 이 목적을 위해,

[13:26 ~ 13:42]
백엔드의 TRPC 라우트로 이동하여 gitlink 호출을 추가해 봅시다. 여기서 일부 더미 데이터가 있다는 것을 알 수 있습니다. 따라서 제가 할 일은 기본적으로 input을 말할 것입니다. 이것은 링크 ID를 가져올 것이고, 그런 다음 await라고 말할 수 있습니다. const data는 await get link와 같습니다.

[13:42 ~ 14:02]
그것이 가져와야 할 것이고, 해당 링크 ID를 전달할 것입니다. 따라서 이 데이터는 여기 아래에 있는 이 더미 데이터와 동일한 모양이 될 것입니다. 따라서 저는 이 녀석을 삭제할 것입니다. 또한 TRPC 오류가 발생합니다. 따라서 어떤 이유로든 해당 링크를 찾을 수 없는 페이지로 이동하면 TRBC not found 오류가 발생합니다.

[14:02 ~ 14:27]
따라서 여기로 돌아가면, 이것이 로드될 때, 실제 제품 이름을 얻을 수 있다는 것을 알 수 있습니다. 그리고 실제로 실제 기본 URL을 얻어야 합니다. 따라서 이것도 업데이트할 수 있습니다. 그래서 저는 test.com이라고 말할 것입니다. 그런 다음 저장할 것입니다.

[14:27 ~ 14:48]
페이지를 새로 고치면, 무엇을 알 수 있습니까? 아마도 그것은. 오, 아직 그건 안 했어요. 죄송합니다. 하지만 여기서 주목할 점은 이 데이터가 실제로 올바르다는 것입니다. 우리는 실제로 이 뮤테이션을 가져야 합니다. 제가 좀 앞서가고 있네요. 그래서 다음 할 일은 링크 이름을 업데이트하는 것입니다.

[14:48 ~ 15:26]
따라서 UI 프로젝트로 이동하면 해당 링크 이름을 포함하는 입력이 있는 섹션을 찾을 수 있을 것입니다. 따라서 코드의 프런트엔드로 돌아가서 링크 이름을 검색할 것입니다. 그리고 그것은 실제로 구성 요소에 더 깊이 계층화되어 있는 것 같습니다. 따라서 여기를 통해 스캔하면 이 링크 이름 편집기가 있다는 것을 알 수 있습니다. 이것은 개별 구성 요소가 될 것이고, link info.name과 ID를 가져옵니다. 따라서 해당 링크 편집기로 이동하면 뮤테이션이 있다는 것을 알 수 있습니다.

[15:26 ~ 16:01]
따라서 우리는 기본적으로 백엔드에 update link name이라는 뮤테이션이 있다고 말합니다. 그리고 이 뮤테이션은 양식 제출 시 사용될 것입니다. 따라서 기본적으로 사용자가 이 버튼을 클릭하면, 사용자가 이 버튼을 클릭하면 Handle save가 호출되고 Handle save는 이 뮤테이션에 데이터를 전달할 것입니다. 따라서 우리는 링크 ID와 이름이 필요합니다.

[16:01 ~ 16:26]
백엔드에 필요한 것입니다. 따라서 백엔드로 이동하면 기본적으로 이 뮤테이션이 입력을 콘솔 로깅하는 것을 볼 수 있습니다. 링크 ID와 링크 이름입니다. 우리는 await update link name을 말할 수 있고, 그런 다음 input.link ID를 전달할 수 있습니다. 왜냐하면 링크 ID를 가져오고 이름도 가져오기 때문입니다. 그런 다음 input에서 정의된 새 이름을 말할 것입니다. 이제 UI로 이동하면,

[16:26 ~ 17:14]
우리는 말할 수 있습니다. 좋아요, 이것을 편집하겠습니다. 그래서 편집을 누르면 편집 중인 상태를 전환합니다. 그런 다음 Product three new name이라고 말할 수 있습니다. 계속해서 저장하십시오. 이제 이 페이지를 새로 고치면, 상태가 실제로 보존된다는 것을 알 수 있습니다. 따라서 이것은 실제로 데이터베이스에서 업데이트되고 있습니다. 그리고 그것을 증명하기 위해, 데이터베이스로 이동하여 이 쿼리를 다시 실행할 수 있습니다. 그리고 우리는 이름이 Product three new name이 될 것이라는 것을 볼 수 있습니다. UI로 돌아가서, 좋아요, 그냥 Product three로 돌려 놓읍시다. 원래 이름이었습니다. 저장을 누를 것입니다. 이것이 작동한다는 것을 증명하기 위해 데이터베이스로 이동할 수도 있습니다. 그리고 이것이 이제 Product three라는 것을 볼 수 있습니다.

[17:14 ~ 18:07]
따라서 우리는 뮤테이션 쿼리를 실행할 수 있는 이 CRUD 작업을 수행할 수 있습니다. 그리고 Tanstack 뮤테이션을 이전에 사용해 본 적이 없다면, 꽤 멋집니다. 예를 들어, 이것을 변경하면, 이 녀석을 누르면 요청이 이루어지는 것을 알 수 있습니다. 이것은 정말 단지 POST 요청입니다. 특별한 것은 없습니다. 일반적인 HTTP 요청 외에는 아무것도 하지 않습니다. 이 녀석을 복사할 수 있고, curl을 복사할 수 있으며, 실제로 curl로 볼 수 있습니다. 따라서 그것은 단지, 그것은 정말 단지 매우 일반적인 HTTP 요청과 같습니다. 특별한 것은 없습니다. 코드에서는 우리 JavaScript의 일부인 함수처럼 보이지만, HTTP 요청을 감싸는 래퍼일 뿐이며, 유형 파싱 등을 관리할 수 있습니다. 그래서 꽤 멋집니다.

[18:07 ~ 18:42]
따라서 CRUD 작업 측면에서 우리가 하고 싶은 마지막 일은 지리적 라우팅을 활성화하는 것입니다. 따라서 UI로 이동하여 링크 ID 페이지로 돌아가면 geolinks 토글이 있다는 것을 볼 수 있을 것입니다. 그리고 이 geolinks 토글에서 업데이트 대상 뮤테이션으로 정의하는 뮤테이션이 있다는 것을 알 수 있습니다. 그리고 기본적으로 그것이 하는 일은 지리적 라우팅 대상에 대한 모든 유형의 변경 사항을 가져와 TRPC 사이트에서도 업데이트하는 것입니다. 따라서 여기서 이 업데이트 링크 대상 TRPC 라우트가 있다는 것을 볼 수 있습니다.

[18:42 ~ 18:59]
그것을 드릴다운하여 백엔드로 이동할 수 있습니다. 따라서 작업자 TRPC 라우트 라우터, 그런 다음 링크가 될 것입니다. 그리고 이것이 우리의 업데이트 대상 링크이며, 이것이 우리의 업데이트 대상 링크 라우트이며, 이것은 ID를 가져옵니다.