WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:900000

[00:00 ~ 00:15]
네, 이제 데이터베이스가 생성되었고, 테이블을 만들었으며 해당 테이블 스키마를 프로젝트로 가져와 타입스크립트 객체로 표현했습니다. 
이제 실제로 링크 정보를 생성하고 저장하는 쿼리를 작성하는 과정을 진행해 보겠습니다.

[00:16 ~ 00:37]
이제 제가 할 일은 프로젝트 내의 `user-application`인 앱으로 이동하는 것입니다. 
저는 이 애플리케이션들을 분리해서 탐색하고 무슨 일이 일어나고 있는지 더 쉽게 볼 수 있도록 하고 싶습니다. 
하지만 여러분은 이렇게 할 필요는 없습니다. 
이 모노레포 안에서 작업할 수 있습니다. 하지만 저는 앱과 `user-application`으로 cd명령어로 들어가겠습니다.

[00:38 ~ 00:58]
그리고 `user-application`을 자체 프로젝트로 열 것입니다. 
이렇게 하면 여러분이 무슨 일이 일어나고 있는지 더 쉽게 볼 수 있을 것입니다. 네, 그렇게 하겠습니다. 
여기에 새 터미널을 열고 pnpm run dev를 실행한 다음, 여러분이 무슨 일이 일어나고 있는지 더 명확하게 볼 수 있도록 꽤 많이 확대하겠습니다.

[00:58 ~ 01:09]
이제 애플리케이션이 실행되었으니, 이동해서 실제로 링크 생성 로직을 구축하는 과정을 시작하겠습니다.

[01:09 ~ 01:34]
따라서 이 링크 생성 버튼으로 이동하면 기본적으로 어떤 종류의 이름을 지정해야 한다는 것을 알 수 있습니다. 
예를 들어 임의의 제품이라고 말할 수 있고, 링크를 제공할 것입니다. 누군가 클릭하면 라우팅될 링크입니다. 
그리고 생성을 누르면 생성되고 이 대시보드로 이동합니다. 지금은 이것이 그냥 더미 데이터라는 것이 분명하지만, 우리는 실제로 그 로직을 구축할 것입니다.

[01:34 ~ 01:57]
따라서 링크 생성으로 이동하고 `user-application`으로 슬라이드한 다음 라우트로 이동하겠습니다. 
앱 내부의 라우트에 `routes/auth/create.tsx` 가 있습니다. 이것이 생성 페이지입니다. 
그리고 여기서 우리가 주목할 것은 뮤테이션이 있다는 것입니다. 
그리고 그 뮤테이션은 실제로 링크 정보를 저장하기 위해 서버 측 코드를 호출하는 함수입니다.

[01:57 ~ 02:20]
그리고 여기서 일어나는 일은 Create를 찾을 수 있는지 확인하는 것입니다. Create 뮤테이션은 기본적으로 이 뮤테이션을 호출하는 Create 버튼입니다. 
그리고 그 뮤테이션을 호출하고 성공적으로 해결되면 특정 링크 페이지로 이동합니다. 
따라서 우리가 하고 싶은 것은 실제로 백엔드에 있는 것을 구축하는 것입니다.

[02:20 ~ 02:45]
따라서 뮤테이션으로 이동하면 마우스 오른쪽 버튼을 클릭하거나 명령 클릭하여 실제 worker 코드로 드릴다운할 수 있습니다. 
또는 그렇게 하지 않으면 소스를 보면 Worker로 이동하여 라우트로 이동하고 링크로 이동한 다음 링크로 이동하겠습니다. 
그러면 이 특정 뮤테이션인 Create Link가 표시됩니다.

[02:46 ~ 03:04]
이제 입력 스키마도 있습니다. 
그리고 이것에 대해 너무 깊이 다루고 싶지는 않지만 기본적으로 Zod라는 라이브러리를 사용하여 해당 입력이 어떻게 생겼는지 정의합니다. 
그리고 유효성 검사를 수행하고 해당 타입이 아니면 오류를 발생시킵니다. 이것은 실제로 모노레포 내의 Data Ops 패키지 내에서 정의됩니다.

[03:04 ~ 03:20]
따라서 우리는 해당 Data Ops 패키지로 이동하여 이 Create Link 스키마가 무엇인지 확인한 다음, 입력 데이터를 가져와 데이터베이스 내에 저장하는 로직을 실제로 구축할 것입니다.

[03:20 ~ 03:46]
이제 Data Ops 패키지로 이동하겠습니다. 
먼저 소스 아래를 살펴보겠습니다. Zod로 이동하고 링크로 이동하면 이 스키마가 어떻게 생겼는지 볼 수 있습니다. 
따라서 링크 스키마는 기본적으로 이것을 사용합니다. 기본적으로 이 객체를 입력으로 사용합니다. 
링크 ID, 계정 ID를 사용하는데, 이것은 애플리케이션에 인증을 실제로 통합할 때 사용됩니다.

[03:46 ~ 04:14]
지금은 이것이 그냥 더미 데이터일 것입니다. 이 입력에서 본 것처럼 이름을 사용하고, 대상을 사용하고, 다른 Zod 객체인 대상을 사용하는데, 이것은 기본적으로 키-값 쌍의 객체와 같습니다. 
그리고 우리가 하고 있는 것은 그것을 연결하고 기본적으로 입력으로 가리키는 것입니다. 
따라서 이것은 UI에서 전송될 것으로 예상되는 특정 데이터 타입이며 실제로 쿼리를 생성하기 위한 것입니다.

[04:14 ~ 04:44]
우리가 할 수 있는 것은 여기에 새 폴더를 만드는 것입니다. 소스 아래에 새 폴더를 만들고 쿼리라고 부를 것입니다. 
그리고 그 폴더 안에 새 파일을 만들고 이것을 Links ts라고 부르겠습니다. 이제 Links ts. 
우리가 하고 싶은 것은 실제로 데이터베이스에 데이터를 삽입하는 이 Create 링크 쿼리를 만드는 것입니다.

[04:44 ~ 05:07]
그래서 우리는 export 함수, Create link를 말할 수 있고, 실제로 이것을 비동기로 만들 것입니다. 
이제 이 create link는 일부 데이터를 가져오고 그 데이터는 Zod 스키마 내에서 정의한 Create 링크 타입이 될 것입니다.

[05:07 ~ 05:36]
그래서 우리가 여기서 볼 수 있습니다. 네, 이 이름이 있고, Create link 스키마 타입인 이 타입이 있습니다. 
그리고 그것이 가져왔는지 확인하고 실제로 해당 파일로 이동하여 볼 수 있습니다. 
따라서 기본적으로 우리가 말하는 것은 이 Create links 홀수 스키마가 있고 우리가 할 일은 그 타입을 내보내는 것입니다. 
따라서 Zod 추론 타입이 있고 Create link 타입 스키마가 있습니다.

[05:36 ~ 06:01]
따라서 이것은 코드를 매우 타입 안전하게 만들고 자동 완성에도 도움이 됩니다. AI는 더 빨리 이해하고 완료할 수 있어서 정말 좋습니다. 
따라서 우리가 하고 있는 것은 전달되는 데이터가 create link 모양이어야 한다고 말하는 것입니다. 
그리고 추가적으로 계정 ID가 필요합니다. 왜냐하면 이 타입에서는 실제로 계정 ID를 생략하기 때문입니다. 
이것은 TRPC 라우트에 의해 제공될 것이며 그것이 어떻게 보일지 보여 드리겠습니다.

[06:01 ~ 06:24]
따라서 이 함수로 돌아가면, 먼저 데이터베이스를 가져오자고 말할 수 있습니다. const와 DB는 get db와 같습니다. 
그리고 get DB가 어디서 왔는지 궁금해하실 것입니다. 이것은 제가 모노레포를 구축할 때 취하는 과정의 첫 번째 단계입니다. 
데이터베이스에 대한 getter와 setter를 만듭니다.

[06:24 ~ 06:49]
따라서 이 파일로 이동하면 database TS에 있을 것입니다. 
우리가 보게 될 것은 드리즐을 드리즐의 D1 패키지에서 가져오는 이 매우 간단한 로직이 있다는 것입니다. 
그런 다음 기본적으로 드리즐의 반환 타입을 가진 데이터베이스 또는 DB를 정의하고 있습니다. 
그리고 이 함수가 있고 이 함수는 init database이며 D1 데이터베이스를 가져와서 전역으로 설정합니다.

[06:49 ~ 07:16]
이제 우리가 할 수 있는 것은 애플리케이션이 실행되고 시작되고 요청을 받으면 요청을 받을 때 가장 먼저 할 일은 이 init database 메서드를 호출하는 것입니다. 
그러면 요청의 나머지 수명 주기 동안 사용할 수 있도록 이 데이터베이스가 설정됩니다. 
그리고 여기서 일어나는 일은 애플리케이션 코드 내에서 쿼리를 가져오고 생성하는 것을 추상화할 수 있다는 것입니다. 
그리고 그것은 모두 이 패키지로 푸시될 것입니다.

[07:17 ~ 07:42]
거기에서 get db라는 함수를 내보냅니다. 이것은 말 그대로 바로 여기에서 이 DB를 가져오려고 하는 것입니다. 
그리고 해당 DB가 인스턴스화되지 않았다면, 우리가 처음 요청을 받을 때 이것을 호출하지 않으면 이 오류가 표시됩니다. 
그리고 이 오류가 표시되면 무엇이 잘못되었는지 정확히 알 수 있으며 인스턴스화되었는지 확인하면 됩니다. 
따라서 이것은 새 서비스나 애플리케이션을 구축할 때 수행하는 일회성 설정과 같습니다. 이제 쿼리로 돌아가서 이 쿼리를 작성하겠습니다.

[07:42 ~ 08:22]
여기서 제가 할 몇 가지 일은 실제 링크 ID처럼 사용되거나 전달될 ID를 만드는 것입니다. 
그리고 나노 ID는 좋지만 훨씬 작습니다. 왜냐하면 이 링크가 너무 길지 않기를 바라기 때문입니다. 
짧은 링크 시스템과 같기 때문입니다. 그런 다음 우리는 await db.insvert를 입력하고 링크 테이블을 전달할 것입니다. 
따라서 이 링크 테이블은 Drizzle Kit 명령에 의해 생성된 스키마에서 가져와야 합니다. 
npm run pull을 입력하면, 우리는 이 실제 링크 스키마를 가져올 수 있었습니다. 이것은 해당 명령에 의해 자동 생성되었습니다.

[08:22 ~ 08:57]
그리고 이 쿼리를 계속 작성하여 값을 삽입하겠습니다. 
그리고 이것들 중 일부를 복사하여 붙여넣겠습니다. ID, 계정 이름(여기서 정의된 data.account name)을 전달할 것입니다. 
그런 다음 여기서 전달된 데이터 이름을 전달하고 destinations 객체를 JSON으로 문자열화할 것입니다. 
따라서 링크가 라우팅될 수 있는 모든 대상을 저장할 것입니다. 그리고 이것이 우리가 여기서 해야 할 전부입니다.

[08:57 ~ 09:19]
제가 하고 싶은 마지막 한 가지는 정의된 ID를 반환하는 것입니다. 
다시 한 번 강조하자면, 이 함수가 있고 이 함수는 Create Link라고 불립니다. 
이것은 TRPC 라우트 내에서 사용될 것입니다. 
우리는 이 패키지 내에서 정의한 데이터베이스 getter에서 데이터베이스를 가져오고, 임의의 ID를 만들고, 그런 다음 데이터를 데이터베이스에 삽입합니다.

[09:20 ~ 09:54]
이제 우리가 하고 싶은 것은 이 프로젝트를 실제로 어떻게 빌드하여 애플리케이션에서 사용할 수 있는지 이해하는 것입니다. 
따라서 이 데이터 옵스 패키지 내의 package JSON을 보면 Repo Data Ops라는 이름을 지정했습니다. 
이것이 프로젝트 또는 패키지 이름입니다. 그리고 이 내보내기 스크립트가 있는데, 모노레포에서 작업한 적이 없다면 pnpm과 같이 내보내기 스크립트를 정의할 수 있다는 것에 익숙하지 않을 수 있습니다.

[09:54 ~ 10:22]
그리고 이것이 하는 일은 기본적으로 이 패키지가 이러한 특정 경로에 액세스할 수 있어야 한다는 것입니다. 
따라서 데이터베이스 경로, 쿼리 경로에서 항목을 가져올 수 있어야 합니다. 
이 특정 쿼리를 정의한 동일한 폴더에 있습니다. 그리고 기본적으로 우리가 하고 있는 것은 이 폴더 내의 모든 쿼리 파일을 탐색하고 이것이 빌드될 때 타입을 지정하고 해당 JS 파일이 어디에 있는지도 지정하는 것입니다.

[10:22 ~ 10:41]
우리는 SOD 스키마와 여기에 있는 몇 가지 다른 것들에 대해서도 동일한 작업을 수행하고 있습니다. 
이것이 모노레포 패키지의 구성입니다. 
그리고 우리가 할 일은 데이터 옵스 패키지에 있는지 확인하고 pnpm run build를 실행하는 것입니다.

[10:41 ~ 11:04]
그러면 코드가 빌드되고 dist 폴더로 출력됩니다. 그리고 여기서 주목할 점은 dist 폴더에 동일한 경로가 있다는 것입니다. 
예를 들어 run을 실행하면 dist가 있고 데이터베이스 또는 DB 데이터베이스 js가 있어야 합니다. DB 데이터베이스 js. 쿼리도 마찬가지입니다. 
따라서 쿼리 폴더가 있고 기본적으로 코드가 JS 형식으로 여기에 내보내졌습니다. 그리고 해당 타입도 내보냈습니다.

[11:05 ~ 11:20]
따라서 이제 우리 `user-application`으로 돌아가서 package JSON 파일로 이동하면 여기에 정의된 프로젝트인 Repo DataOps가 있다는 것을 알 수 있습니다.

[11:20 ~ 11:39]
그리고 이것은 실제로. 따라서 여기 버전을 보면 숫자 버전이 아니라 워크스페이스에서 온 것입니다. 
이것은 PMPM에 특정한 것으로, 기본적으로 이 패키지는 워크스페이스에서 올 것이라고 말하는 것입니다. 
따라서 워크스페이스를 보고 내보내기가 정의된 곳에서 해당 파일을 가져와야 한다는 것을 알고 있습니다. 이 워크스페이스 내에서.

[11:39 ~ 11:54]
좋아요, 이제 우리가 하고 싶은 것은 링크라는 TRPC 라우트로 다시 돌아가서 이 Create link 메서드가 있는 곳으로 가는 것입니다.

[11:54 ~ 12:21]
그리고 우리가 할 일은 기본적으로 trpc에서 입력을 가져와서 이 입력이 입력에서 온 것을 볼 수 있다고 말하는 것입니다. 
이름, 대상, UI에서 전송되는 일부 정보가 있습니다. 그리고 우리는 await라고 말하고 이 메서드를 호출할 것입니다. 
이것은 데이터 옵스에서 이것을 가져올 수 있어야 합니다. 따라서 쿼리에서 links로 전달할 수 있습니다.

[12:22 ~ 12:47]
좋아요, 이 메서드 Create Links가 있습니다. 우리는 코드의 create link, 여기서 정의한 Create link 프로시저로 이동합니다. 
그리고 우리는 단순히 이 데이터를 넣을 것입니다. 따라서 우리는 말할 것입니다, 좋아요, 우리가 할 수 있는 것은.

[12:47 ~ 13:17]
그래서 제 생각에는 다른 한 가지가 있습니다. 우리는 또한 ctx를 노출하고 싶을 것입니다. 
이것이 컨텍스트입니다. 따라서 trpc를 사용하면 기본적으로 데이터를 가져오겠다고 말하면 여기에 많은 정보가 있습니다. 
data dot input이 있습니다. 이것은 프로시저 내에서 정의된 입력입니다. 
또한 요청과 관련된 몇 가지 속성이 있고 추가하는 추가 사항이 있는 컨텍스트도 있습니다. 우리는 잠시 후에 이것에 대해 알아볼 것입니다.

[13:18 ~ 13:44]
따라서 기본적으로 여기서 우리가 하고 있는 것은 컨텍스트와 입력만 가져오면 된다고 말하는 것입니다. 
그리고 입력은 양식의 입력이므로 여기에 입력하고 있습니다. 그리고 계정 ID는 실제로 인증 프레임워크에서 제공될 사용자 ID입니다. 
지금 당장 하고 싶은 것은 UI를 실제로 사용하고 싶고 오류가 발생할 것입니다. 
오류가 발생하면 실제로 왜 오류가 발생하는지 생각해 보세요.

[13:44 ~ 14:05]
그래서 여기로 와서 검사하고 네트워크로 이동한 다음 기본적으로 가짜 제품 이름, 제품 1을 제공하고 임의의 대상 URL을 갖고 생성을 누를 것입니다. 
그리고 볼 수 있듯이 링크 생성이 실패했습니다. 여기서 500을 받았습니다. 내부 서비스 오류와 같은 일반적인 오류가 발생할 것입니다.

[14:05 ~ 14:25]
그리고 오류는 데이터베이스가 초기화되지 않았다는 것입니다. 기억하시겠지만, 우리는 데이터베이스 로직을 만들었습니다. 
여기서 우리는 요청을 처음 받을 때 데이터베이스를 초기화해야 합니다. 
따라서 클라우드플레어 워커를 사용하여 이 내용을 닫으면. 따라서 `user-application`의 워커로 와서 인덱스로 오면 이 매우 일반적인 기본 페치 핸들러가 있다는 것을 알 수 있습니다.

[14:26 ~ 14:51]
그리고 우리는 받고 있고, 페치 메서드를 정의하고 있으며, 모든 바인딩 및 모든 것이 포함된 요청과 EMV를 받고 있습니다. 
그리고 우리가 하고 있는 것은 기본적으로 경로가 trpc인 경우 해당 요청을 trpc를 구현하는 이 페치 요청 핸들러에 전달할 것이라고 말하는 것입니다. 
따라서 요청을 내부적으로 TRPC 핸들러로 라우팅하는 것과 같습니다.

[14:52 ~ 15:10]
따라서 이것은 기본적으로 요청의 진입점입니다. 따라서 우리는 init database를 말할 수 있고 그것을 가져올 것입니다. 
따라서 그것은 ops 데이터베이스에서 올 것이고 env.db를 전달할 수 있습니다. env.db를.

[15:14 ~ 15:33]
아, 네, 여기서 주목해야 할 또 다른 사항이 있습니다. 
그래서 우리는 Cloudflare에서 데이터베이스를 만들었고, 해당 테이블을 만들었지만, 여기에서 실제 worker와 바인딩해야 합니다. 
따라서 Wrangler JSON 파일로 이동하여 A D1 데이터베이스를 말할 것입니다.

[15:37 ~ 16:03]
그리고 바인딩을 전달할 것입니다. db입니다. 그리고 실제 데이터베이스 ID도 전달하고 싶을 것입니다. 
따라서 Cloudflare로 돌아가서 데이터베이스로 이동하여 해당 링크를 복사하고 이 데이터베이스 ID를 붙여넣은 다음 마지막으로 이것이 작동하도록 하기 위해 할 일은 Cloudflare의 실제 데이터베이스에 데이터를 실제로 보내는 것입니다.

[16:03 ~ 16:20]
remote을 활성화할 것입니다. 하지만 그 전에 실제로 이것을 아직 활성화하지 않을 것입니다. 
여기서 무슨 일이 일어나는지 보여 드리겠습니다. 
이제 이 항목이 구성되었으므로 해당 애플리케이션을 종료하고 pnpm을 실행하고 CF 타입 생성을 실행하면 타입이 생성됩니다.

[16:20 ~ 16:48]
따라서 이 worker 구성으로 이동하면 이제 이 D1 데이터베이스가 이 Cloudflare 환경의 네임스페이스의 일부라는 것을 알 수 있습니다. 
이제 인덱스 파일, 즉 worker의 진입점으로 돌아갈 수 있습니다. 그리고 이것이 더 이상 타입 오류를 발생시키지 않는다는 것을 알 수 있습니다. 
따라서 데이터베이스를 성공적으로 인스턴스화할 수 있습니다.

[16:48 ~ 17:15]
따라서 이제 애플리케이션을 실행하고 해당 쿼리를 다시 제출하려고 하면 오류가 발생해서는 안 됩니다. 
하지만 실제 데이터베이스로 데이터를 보내지는 않을 것입니다. 따라서 이것이 로드되면 제가 무슨 뜻인지 정확히 보여 드리겠습니다. 
좋아요, 제품 1이라고 말하고 대상을 지정하고 링크 생성을 누를 것입니다. 다른 오류가 발생한 것 같습니다. 
여기서 무슨 일이 일어나고 있는지 빨리 파악할 수 있는지 봅시다.

[17:15 ~ 17:48]
네, 좋아요, 오류가 있다는 것을 알 수 있습니다. 여기서 오류가 발생하는 이유는 이것이 실제로 로컬 데이터베이스에 데이터를 삽입하려고 하기 때문입니다. 
따라서 dev 스크립트를 실행하면 기본적으로 가짜 테이블 또는 wrangler 폴더 상태 및 여기에 로컬 테이블과 같은 것을 만듭니다. 
따라서 이것이 실제로 SQLite 파일이 될 것임을 알 수 있습니다.

[17:48 ~ 18:09]
따라서 프로젝트의 모든 것은 로컬에서 실행될 때 실제로 이 테이블에서 데이터를 소싱하려고 시도합니다. 
그리고 우리가 얻는 오류는 기본적으로 데이터를 삽입하는 링크 테이블이 생성되지 않았다는 것입니다. 
이제 기술적으로 명령을 실행하고 이 로컬에서 실행되는 SQLite 데이터베이스에서 해당 쿼리를 생성할 수 있습니다. 
하지만 정말 지루합니다. 그리고 이제 Cloudflare에 이 기능이 있기 때문에,

[18:09 ~ 18:28]
remote 실행을 위해 Wrangler JSON 파일로 다시 이동할 수 있습니다. 
remote 를 true로 실행하도록 지정할 것입니다. 그리고 한 가지 주목할 점은 오늘 현재 문서에서 실제로 명확하지 않다는 것입니다. 
vite.config.ts으로 이동하면 여기에 있습니다. Cloudflare vite 플러그인이 있다는 것을 알 수 있습니다.

[18:28 ~ 18:50]
우리는 또한 여기에 와서 실험적이라고 말하고 싶을 것입니다. 그러면 원격 바인딩이 true가 될 것입니다. 
따라서 기본적으로 이것은 동일한 타입의 구성입니다. 이것은 단지 우리의 Cloudflare vite.config.ts에 그것이 사실이라고 알려줍니다. 
이제 제가 해야 할 일은. Wrangler 로그아웃을 실행할 것입니다.

[18:50 ~ 19:10]
제가 이렇게 하는 유일한 이유는 제가 연결된 다른 Cloudflare 계정이 있기 때문입니다. 
올바른 계정에 연결되었는지 확인하고 싶습니다. Wrangler 로그아웃을 실행할 필요는 없을 것입니다. 
그리고 pnpm run dev를 말할 것입니다. 그러면 애플리케이션이 다시 시작됩니다. 그리고 그것이 한 일은 실제로.

[19:11 ~ 19:33]
실제로 새 탭을 열었습니다. 그리고 이 과정을 한 번 거친 것 같습니다. 
하지만 기본적으로 우리가 D1 데이터베이스에 연결할 권한이 있는지 묻는 것입니다. 
remote으로 실행하고 있기 때문에. remote으로. True. 따라서 허용하겠습니다. 
이제 여기로 돌아와서 이것이 실제로 성공적으로 실행되고 있음을 볼 수 있습니다.

[19:33 ~ 19:51]
마지막으로 한 번 더 시도해 보겠습니다. 또 다른 주목할 점은 오늘 현재 실험적인 개발을 실행할 때 실제로 설정하고 연결하고 Cloudflare 서버와 인증하는 데 1분이 걸린다는 것입니다. 
따라서 로딩 페이지가 배포했을 때보다 실제로 약간 더 길다는 것을 알 수 있을 것입니다.