WEBVTT
X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:900000

00:00:00.356 --> 00:00:08.516
자, 드디어 강의의 정말 재미있는 부분에 도달했습니다. 이제 모든 것을 실제로 구축하기 시작할 것이고, 솔직히 가장 좋은 학습 방법인 직접 해보면서 배울 것입니다.

00:00:08.516 --> 00:00:17.476
제가 다음 12시간 동안 강의만 하는 대신, 코드를 매우 깊이 파고들 것이며, 프론트엔드부터 시작하여 천천히 백엔드로 이동할 것입니다.

00:00:17.716 --> 00:00:22.276
스택의 더 깊은 곳으로 갈수록 자료는 더욱 심층적으로 다루어질 것입니다.

00:00:22.356 --> 00:00:27.656
그러니 프론트엔드를 너무 빠르게 진행한다고 해서 압도되지 마십시오. 저는 어느 정도 그럴 것이라고 예상합니다.

00:00:27.806 --> 00:00:38.086
이 강좌는 Cloudflare 위에서 구축하는 방법을 프레임워크에 구애받지 않고 살펴보는 것을 목표로 하며, 어떤 프레임워크든 가져올 수 있고, 백엔드에서 서비스를 구축하는 방법을 진정으로 이해하는 데 도움이 되도록 구성되어 있습니다.

00:00:38.086 --> 00:00:44.170
그래서 우리는 프론트엔드를 살펴볼 것입니다. 페이지 탐색이 어떻게 작동하는지, 그리고 우리가 사용하는 다양한 기술들을 살펴볼 것입니다.

00:00:44.170 --> 00:00:48.930
하지만 이 모든 것을 많이 이해하지 못하더라도 너무 압도되지 마십시오. 왜냐하면 우리가 하려는 것이 아니기 때문입니다.

00:00:48.930 --> 00:00:54.730
우리는 이 프레임워크를 사용하는 방법이나 React와 tRPC를 사용하는 방법을 가르치려 하지 않습니다. 저는 단지 우리가 그것을 어떻게 사용하고 있는지 보여주고 싶을 뿐입니다.

00:00:54.890 --> 00:00:58.480
그러면 이 프로젝트 구조와 탐색 방법을 확고히 하는 데 도움이 될 것입니다.

00:00:58.560 --> 00:01:06.162
그래서 우리가 할 일은 Apps User Application으로 이동할 것입니다. 이것은 우리의 프론트엔드이며, 해당 디렉토리로 CD도 할 것입니다. Apps User Application으로 가서 `pnpm run dev`를 실행할 것입니다.

00:01:06.162 --> 00:01:12.362
그러면 우리 애플리케이션이 부팅될 것입니다.

00:01:12.842 --> 00:01:19.962
여기서 보면, 우리 애플리케이션이 실행 중인 포트 3000의 홈페이지로 이동할 것입니다. 이것이 홈페이지입니다.

00:01:19.962 --> 00:01:36.434
이제 '무료로 시작하기'를 클릭하면 우리를 '/app'으로 이동시킵니다. 이것은 사용자 애플리케이션의 대시보드 섹션과 같은 곳이며, 사용자가 링크를 관리하고 애플리케이션과 실제로 상호 작용하는 곳입니다.

00:01:36.674 --> 00:01:46.984
이것은 또한 강좌의 끝부분쯤에 우리는 일부 인증을 구현할 것입니다. 따라서 '/app'은 인증된 로그인 사용자만 이 페이지의 내용을 볼 수 있도록 보호될 것입니다.

00:01:47.624 --> 00:01:49.464
그렇다면 지금 이것을 어떻게 하고 있을까요?

00:01:49.464 --> 00:02:06.344
이 애플리케이션은 매우 간단하게 React로 설정되어 있습니다. 페이지 탐색을 위해 Tanstack 라우터를 사용하고 있으며, 프론트엔드에서 백엔드로 전달되는 데이터는 Cloudflare Workers에서 실행되는 매우 가벼운 워커에서 제공되는 tRPC를 통해 이루어집니다. 그래서 지금 바로 그 부분으로 들어갈 것입니다.

00:02:06.344 --> 00:02:22.484
이제 소스로 이동하여 `Routes`를 살펴보면, Next.js에 익숙하다면 매우 유사한 규칙이라는 것을 알 수 있습니다. 유일한 차이점은 `page.tsx`와 같은 것이 없다는 것입니다. 그게 규칙이 아닙니다. 기본적으로 `Routes` 내의 어떤 파일 이름이든 자체 페이지가 됩니다.

00:02:22.724 --> 00:02:45.372
그리고 여기서 볼 수 있듯이, 이것은 앱 내의 인덱스이며 이것은 홈페이지입니다. 그리고 앱을 보면, 즉 '/app'이 경로가 될 것입니다. 이 `_auth` 내부에 있습니다. 이것은 보호되어 있으므로 이 강좌 후반에 이것이 어떻게 작동하는지 살펴볼 것입니다. 하지만 `_auth` 내부에 이 `index.tsx`가 있고, 이것이 바로 우리가 지금 보고 있는 대시보드 페이지입니다.

00:02:45.372 --> 00:02:51.308
이 대시보드는 백엔드의 다양한 tRPC 엔드포인트에서 데이터를 가져오고 있습니다.

00:02:51.628 --> 00:03:17.518
그리고 여러분이 보게 될 것은, 페이지가 로드될 때 모든 로직이 실행되는 `loader`라는 매우 일반적인 규칙이 있다는 것입니다. 그리고 이 로직은 기본적으로 tRPC 라우트 뒤에 있는 많은 데이터를 미리 가져오는 것입니다. 즉, 데이터베이스에서 데이터를 가져와 프론트엔드로 다시 제공할 백엔드 핸들러 뒤에 있는 것입니다.

00:03:18.848 --> 00:03:24.968
그리고 우리는 다양한 컴포넌트들을 가질 것입니다. 이 카드들, 이 메트릭 카드들과 몇몇 테이블들이 있습니다.

00:03:24.968 --> 00:03:31.568
그래서 여기 아래로 내려와서 이 테이블인 `top countries table`을 보면, 그것을 자세히 살펴볼 수 있습니다.

00:03:32.044 --> 00:03:36.265
그리고 이것은 매우 전형적인 JSX TSX 컴포넌트 React라는 것을 알 수 있습니다.

00:03:36.745 --> 00:03:47.625
이제 여기서 주요 차이점은 우리가 실제로 데이터를 가져오고 있지만, API 호출을 하고 데이터를 처리하고 모든 것을 구문 분석한 다음 전달하는 전통적인 방식으로는 데이터를 가져오지 않는다는 것입니다.

00:03:48.105 --> 00:03:53.065
우리는 백엔드에서 데이터를 가져오는 방식의 매우 단순화된 버전을 가지고 있습니다.

00:03:53.345 --> 00:03:55.435
그리고 이것은 Tanstack의 `Use query`를 사용하고 있습니다.

00:03:55.675 --> 00:04:06.385
이제 이것은 솔직히 제가 본 것 중 가장 인기 있고 강력한 데이터 가져오기 라이브러리일 것이며, 제 경력 초기에 이것을 사용하지 않았던 것이 어리석다고 느껴집니다. 그리고 그 이유를 보여드리겠습니다.

00:04:06.465 --> 00:04:18.385
따라서 Tanstack 쿼리에 익숙하다면 이 부분을 건너뛰어도 됩니다. 하지만 그렇지 않다면, 솔직히 저는 여러분이 애플리케이션 내에서 가져오기 로직을 구현하는 방식에 변화를 줄 것이라고 생각합니다.

00:04:18.545 --> 00:04:31.305
어떤 프레임워크를 사용하든 상관없습니다. Svelte 버전, Vue, Solid 버전이 있습니다. 그리고 물론 React에서 작업한다면 React 버전도 있습니다. 이것이 가장 먼저 나왔던 것입니다.

00:04:32.025 --> 00:04:51.905
프론트엔드 컴포넌트가 있고 그 컴포넌트가 처음 마운트될 때 백엔드에서 데이터를 가져와야 할 때, 이것은 매우 전형적인 패턴이며 솔직히 잘못된 방식입니다. 하지만 많은 사람들이, 심지어 대기업에서도 이렇게 하는 것을 많이 봅니다. 대기업에서 일하면서 이런 코드를 얼마나 많이 봤는지 셀 수도 없습니다. 솔직히 저도 처음 시작했을 때 이런 코드를 작성했던 것 같습니다. 따라서 사용자가 마운트될 때 `useEffect`가 있고, 그 `useEffect`에는 백엔드에 대한 비동기 데이터 호출이 있습니다.

00:04:51.905 --> 00:05:12.642
그리고 `useEffect` 내에서 비동기 함수를 깔끔하게 정의할 수 없기 때문에 `fetch users` 함수를 정의하고 `useEffect` 내에서 호출해야 하는데, 이는 좀 번거롭습니다.

00:05:13.892 --> 00:05:20.692
하지만 본질적으로 하고 싶은 것은 이 사용자 엔드포인트에서 데이터를 가져와서 사용자 상태를 채우는 것입니다.

00:05:20.852 --> 00:05:31.312
그래서 데이터를 가져오고, 데이터를 받으면 사용자를 설정합니다. 따라서 API에서 응답으로 받은 데이터 사용자들을 설정하고, 그 데이터는 여기 아래 UI에 렌더링됩니다.

00:05:31.712 --> 00:05:38.832
이제 그 API 호출은 몇 초가 걸릴 수 있습니다. 그래서 몇 초가 걸린다면 어떻게 해야 할까요? 로딩 상태가 필요하겠죠? 그래야 애플리케이션이 좀 더 상호 작용적일 수 있습니다.

00:05:38.832 --> 00:05:54.652
그래서 `isLoading` 함수나 `isLoading` 상태 객체를 추가합니다. 그러면 true로 설정되고 데이터 호출이 발생합니다. 모든 것이 완료되면 기본값으로 설정되고, true일 때는 작은 로딩 표시기가 나타나고 false일 때는 로딩 표시기가 사라집니다.

00:05:54.812 --> 00:06:02.972
그리고 오류가 발생하면, 예를 들어 API 오류가 발생하거나 서버가 다운되거나 하는 경우, 깔끔한 오류 메시지도 표시해야 합니다. 그래서 또 다른 상태 변수를 추가합니다.

00:06:02.972 --> 00:06:08.892
이제 이 코드는 솔직히 꽤 좋지 않습니다. 그리고 왜 좋지 않은지 모르더라도 괜찮습니다. 하지만 훨씬 더 좋게 만드는 방법을 보여드리고 싶습니다.

00:06:09.412 --> 00:06:10.772
여기 문제점 중 하나는

00:06:11.092 --> 00:06:13.532
이 데이터, 이 사용자 데이터가 타입 안전하지 않다는 것입니다.

00:06:13.532 --> 00:06:20.252
우리는 사용자가 이름이나 성을 가지고 있는지, 카멜 케이스인지, 이메일을 가지고 있는지 모릅니다. 맞죠? 우리는 그것을 모릅니다.

00:06:20.252 --> 00:06:23.232
그리고 어떤 데이터가 사용 가능한지 확인하려면 콘솔 로그를 찍어봐야 합니다.

00:06:23.812 --> 00:06:29.332
그리고 그 데이터가 변경되면, 우리는 우리 애플리케이션에 오류가 발생할 것이라는 것 외에는 아무것도 알지 못합니다. 그것이 우리가 상황을 알아내는 유일한 방법입니다.

00:06:29.502 --> 00:06:34.462
만약 이것이 실패하고 다시 가져오고 싶다면, 깔끔한 재시도 로직도 없습니다.

00:06:35.032 --> 00:06:38.552
이러한 것들은 Tanstack 쿼리가 엄청나게 도움이 될 것입니다.

00:06:38.632 --> 00:06:46.472
따라서 이 코드를 보면, `useEffect` 함수, `setState`, 상태 기반 렌더링을 확고히 하는 것과 같습니다.

00:06:47.102 --> 00:06:48.862
이제 이것의 더 깔끔한 버전을 살펴보겠습니다.

00:06:49.262 --> 00:06:52.622
Tanstack 쿼리를 사용한 더 깔끔한 버전은 다음과 같습니다.

00:06:52.702 --> 00:07:05.822
fetch 함수를 밖으로 빼냅니다. 따라서 실제로 API와 인터페이스하고 데이터를 가져와 프론트엔드에 제공하는 함수는 밖으로 옮겨졌습니다. 솔직히 이것은 다른 파일에 넣을 것이고, 그러면 다른 컴포넌트에서 재사용될 수 있습니다.

00:07:06.142 --> 00:07:11.522
그런 다음 Tanstack React Query의 `useQuery` 메서드가 있습니다.

00:07:11.682 --> 00:07:19.262
그리고 본질적으로 여기서 일어나는 일은 쿼리 키를 지정하는 것입니다. 이 쿼리 키는 특정 쿼리에 대해 고유할 것입니다.

00:07:19.422 --> 00:07:40.042
쿼리 키가 필요한 이유는 Tanstack이 프론트엔드에서 일부 캐싱을 수행하기 때문입니다. 따라서 동일한 API에서 동일한 엔드포인트에 동일한 입력으로 데이터를 필요로 하는 여러 컴포넌트가 있는 경우, 백엔드에서 데이터를 계속 가져오는 대신, 데이터를 구성하여 '데이터가 몇 초밖에 안 됐다. 다시 가져오지 말고 캐시에서 가져와라'라고 말할 수 있습니다.

00:07:40.042 --> 07:50.364
전체적으로 매우 복잡한 캐싱 설정이 있지만, 너무 깊이 들어가지는 않겠습니다. 그냥 존재한다는 것을 알아두고, 여가 시간에 그것을 구성하는 방법을 찾아볼 수 있습니다.

00:07:50.364 --> 07:58.982
그리고 또 필요한 것은 fetch 함수입니다. fetch 함수는 단순히 함수를 전달하는 것입니다. 호출하는 것이 아니라, 그냥 '이것이 내 함수입니다'라고 말하는 것입니다.

00:07:59.782 --> 08:18.802
그리고 이 컴포넌트가 마운트될 때, 이 함수가 호출될 것이고 Tanstack 쿼리는 기본적으로 '데이터를 가져와야 할까, 아니면 이미 캐시에 데이터가 있을까?'라고 말할 것입니다. 그리고 이미 캐시에 데이터가 있다면 '캐시에 있는 그 데이터를 보여줘'라고 말할 수 있습니다. 하지만 그 데이터가 페이지에 표시되는 동안, 다른 데이터를 가져와서 업데이트할 것입니다.

00:08:18.802 --> 08:27.282
그래서 이 모든 것들을, 이 로직을 구성할 수 있지만, 그냥 바로 사용하면 갑자기 UI가 더 빠릿해지고 관리하기 훨씬 쉬워지는 것을 알 수 있을 것입니다.

00:08:27.362 --> 08:35.800
또한 `useQuery`의 일부로 `isLoading` 속성과 오류 플래그도 있다는 것을 알게 될 것입니다.

00:08:35.800 --> 08:42.624
따라서 이 작은 코드 조각만으로도 여러분은 이렇게 단순화된 것에서 이렇게 바뀔 수 있습니다.

00:08:42.704 --> 09:01.074
재시도를 할 수 있습니다. 또한 제가 언급하지 않은 것이 있다면, 만약 이것이 실패하면 기본적으로 네 번 재시도할 것입니다. 그리고 각 재시도는 지수적으로 백오프될 것입니다. 즉, 즉시 재시도하고, 1초 기다렸다가 재시도하고, 몇 초 더 기다렸다가 재시도하는 식입니다. 그리고 이 로직을 원하지 않으면 비활성화할 수 있습니다.

00:09:01.074 --> 09:13.924
하지만 또 다른 점은 탭을 이동했다가 다른 탭으로 돌아오면, 기본적으로 데이터를 다시 가져올 것이라는 것입니다. 따라서 UI에서 데이터가 오래되지 않을 것이며, 이것 또한 정말 멋집니다.

00:09:13.924 --> 09:21.604
따라서 이것이 얼마나 더 간단한지 알아두십시오. `useQuery`가 제공하는 속성을 기반으로 로딩과 오류 처리를 할 수 있습니다.

00:09:21.844 --> 09:26.924
이제 tRPC는 이것을 한 단계 더 발전시켜 훨씬 더 간단하고 작업하기 쉽게 만듭니다.

00:09:26.924 --> 09:49.555
저에게 있어 주요 이유는, 형태를 알 수 없고 백엔드에서 변경될 수 있는 API에 연결하는 대신, 백엔드에서 그 형태가 변경될 수 있고 프론트엔드가 알지 못하는 경우, 즉 좋은 API를 설계했다면 백엔드에서 변경되어서는 안 되지만, 그런 일이 발생하면 UI가 알지 못합니다. 따라서 프론트엔드에서 예상치 못한 데이터를 받게 되고 문제가 발생하기 시작하며, 사용자들이나 모니터링 도구가 이를 감지할 때까지 알지 못합니다.

00:09:49.715 --> 10:04.575
이제 tRPC는 이것을 한 단계 더 발전시켜, 본질적으로 REST API를 사용하는 대신 API를 타입 안전한 로직으로 감쌀 것이라고 말합니다. 그래서 프론트엔드, 입력 및 출력을 정의할 수 있으며, 해당 데이터의 형태에 대한 컨텍스트를 가진 클라이언트를 사용할 것입니다.

00:10:04.735 --> 10:06.175
그래서 이것은 이렇게 보일 것입니다.

00:10:06.735 --> 10:13.198
그래서 여기를 상상해 보세요. 여기를 보면 tRPC 클라이언트를 가져오고 있습니다. 이것은 일종의 의사 코드입니다.

00:10:13.598 --> 10:20.798
그리고 클라이언트는 사용자 라우트가 있고, 그 사용자 라우트에는 `getAll`이라는 메서드가 있다는 것을 알고 있습니다.

00:10:21.278 --> 10:29.678
그리고 여기서 `useQuery`라는 것을 알 수 있습니다. 우리는 쿼리 키와 쿼리 함수를 명시적으로 정의하고 있지 않습니다. 그래서 이 두 가지를 정의하지 않고 있습니다.

00:10:29.824 --> 10:36.904
우리는 `query options`를 사용하고 있는데, 이것은 tRPC와 함께 React Query를 사용하는 새로운 방법입니다.

00:10:37.384 --> 10:49.804
그래서 그것이 우리를 위해 처리해 주고 있습니다. 기본적으로 호출해야 할 쿼리 함수를 제공하고 있으며, 고유한 키도 제공하고 있어서 어떤 키를 사용하고 있는지 기억하고 있을 필요가 없어서 또한 정말 좋습니다.

00:10:50.254 --> 11:00.904
그리고 이것을 나눌 수 있습니다. 그래서 이것을 나누어 쿼리 대신 데이터만 원하고, `isLoading`만 원하고, 오류만 원한다고 지정할 수 있습니다. 첫 번째 예제에서와 같이 말입니다.

00:11:01.264 --> 11:07.678
이것은 의사 코드일 뿐이지만, 같은 방식으로 처리합니다. 그래서 로딩 처리, 오류 처리, 그리고 사용자 표시를 할 수 있습니다.

00:11:09.454 --> 11:20.814
이제 React Query가 왜 유용한지 이해했고, 프로젝트에서 tRPC를 어떻게 사용할지에 대한 기본 사항도 이해했으니, 코드베이스로 가서 빠르게 살펴보겠습니다.

00:11:21.090 --> 11:32.665
여러분은 우리의 `top countries table`이 `suspense query`를 가지고 있다는 것을 알게 될 것입니다. `useQuery`와 매우 유사합니다. 유일한 차이점은 로딩 상태가 없다는 것입니다. 그저 우리가 데이터를 가지고 있다고 가정하고, 데이터가 없다면 해당 데이터가 있을 때까지 컴포넌트가 렌더링되지 않습니다.

00:11:33.145 --> 11:39.525
그런 다음 우리는 기본적으로 데이터가 'clicks by country'라는 이름의 데이터이며, 그것을 테이블 내부에 렌더링한다고 말합니다.

00:11:39.925 --> 12:00.200
이제 백엔드 코드를 보고 싶다면, 백엔드 코드는 실제로 이 프로젝트의 일부입니다. 그래서 여기서 밖을 보면, `source`와 `worker`가 있습니다. `source`는 프론트엔드 애플리케이션이고, `worker`는 우리의 애플리케이션 프론트엔드를 위한 데이터 인터페이스와 같은 가벼운 Cloudflare Worker입니다.

00:12:00.850 --> 12:10.450
이 tRPC 폴더가 있고, 이 tRPC 폴더에는 우리의 라우터가 있습니다. 그래서 여기에는 라우터가 있고, 링크 라우터와 평가 라우터가 있습니다.

00:12:10.610 --> 12:16.070
링크 라우터에는 우리가 구현한 다양한 메서드들이 있으며, 이들은 모두 타입 안전합니다.

00:12:16.070 --> 12:38.335
그래서 우리가 할 수 있는 것은, 그리고 이것은 솔직히 tRPC의 가장 좋은 점일 것입니다. 타입 안전하다는 점 외에, 만약 제가 프론트엔드에 있고 어딘가에 있는 백엔드 코드를 찾고 싶다면, 프로젝트가 거대하다면 '이걸 찾으러 가서 파일로 점프해야겠다'라고 생각할 것입니다. 하지만 메서드를 Command 클릭하면 이 백엔드 코드로 바로 이동합니다.

00:12:38.335 --> 12:55.565
그래서 지금 백엔드 코드가 하는 일은 입력이 없다고 말하는 것입니다. 그 계정에 대한 데이터만 가져와서, 이 국가들에 대한 더미 데이터 배열을 반환할 것입니다. 그래서 기본적으로 국가 코드와 계정 코드와 같습니다. 그래서 그것이 우리가 그것과 인터페이스하는 방식입니다.

00:12:55.565 --> 13:08.225
이제 이 강좌의 다음 몇 섹션 동안 우리가 할 일은 이것을 위한 백엔드를 구축하기 시작하는 것입니다. 그래서 우리는 데이터베이스를 구축하고 그 테이블들을 만들 것이며, 이 강좌 전반에 걸쳐 이러한 메서드에 연결되는 다양한 쿼리들을 사용할 것입니다.

00:13:09.355 --> 13:23.475
그래서 `const data await my query`와 같은 것이 있을 것입니다. 그래서 백엔드의 데이터베이스를 호출한 다음 그 데이터를 프론트엔드로 반환할 것입니다. 그래서 지금 바로 이것을 구축하기 시작할 것입니다.

00:13:23.475 --> 13:50.185
하지만 이것을 확고히 하는 것이 정말 중요하다고 생각합니다. 우리는 페이지 탐색을 위해 Tanstack 라우터를 사용하는 React 애플리케이션을 가지고 있고, 동일한 프로젝트에 번들링된 가벼운 백엔드에서 데이터를 가져오기 위해 Tanstack Query를 사용하고 있습니다. 즉, 동일한 사용자 애플리케이션 내에서 말입니다. 그리고 그 백엔드는 Cloudflare Worker에 호스팅되어 있습니다. 그리고 그 Cloudflare Worker는 tRPC를 구현했습니다. 따라서 프론트엔드에서 백엔드로 매우 타입 안전한 데이터 교환을 할 수 있습니다.

00:13:50.465 --> 14:12.235
솔직히 이것은 간단한 설정이지만 정말 강력합니다. 그리고 만약 Next를 좋아한다면 괜찮습니다. Next와 함께 tRPC를 사용할 수 있습니다. Next.js에는 이것과 매우 유사한 서버 함수도 제공됩니다. 하지만 이것의 아름다움은 프레임워크에 구애받지 않는다는 것입니다. 어떤 TSX 기반 프로젝트에도 가져올 수 있고 모든 것이 훨씬 쉬워집니다.

00:14:12.235 --> 14:14.075
그래서 우리는 이것을 더 깊이 파고들 것입니다.

00:14:14.086 --> 14:21.450
하지만 이제 프론트엔드에서 tRPC 위에서 실행되는 가벼운 백엔드까지 전체적으로 이해했으니, 이 강좌의 데이터 측면으로 들어가 보겠습니다.