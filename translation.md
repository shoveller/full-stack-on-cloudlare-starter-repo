[00:00:00.556 --> 00:00:04.556] 좋아요, 이제 데이터 서비스의 index.ts 파일로 돌아가 보겠습니다.

[00:00:04.796 --> 00:00:09.196] 보시다시피 여기에는 'hello world'를 반환하는 매우 기본적인 페치 핸들러가 있습니다.

[00:00:09.516 --> 00:00:19.416] 이 데이터 서비스에는 몇 가지 다른 라우트, 즉 사용자가 일부 로직을 처리하기 위해 접근할 수 있는 몇 가지 다른 경로가 있을 것입니다.

[00:00:19.416 --> 00:00:53.912] 그리고 현재 사용자 애플리케이션이 설정된 방식을 보면, 워커가 있고 워커와 index.ts 파일 내부에 'trpc'로 시작하는 경로 이름을 가진 URL이 요청에 의해 제공되면 TRPC 관련 항목을 처리하라고 되어 있습니다. 그리고 만약 다른 라우트가 많다고 상상해보세요. 예를 들어 API 정방향 슬래시 인증, 이 모든 다른 라우트들이요. 그러면 경로를 수동으로 파싱하고 조건부로 라우팅하는 등의 상용구가 많이 생길 것입니다. 그리고

[00:00:54.232 --> 00:01:05.192] 이러한 사용 사례를 구축하게 되면, 페치 핸들러 내에 있어야 할 로직의 유형을 초과하게 됩니다. 그때 다른 라우팅 프레임워크를 도입해야 합니다.

[00:01:05.192 --> 00:01:09.632] 이제 이와 똑같은 것을 수행하는 다양한 웹 프레임워크가 많이 있습니다.

[00:01:10.032 --> 00:01:15.212] 제가 가장 좋아하는 것은 Cloudflare 워커뿐만 아니라 다른 런타임에서도 사용할 수 있는 Hono입니다.

[00:01:15.552 --> 00:01:36.732] Hono는 Cloudflare Worker에서의 개발 프로세스를 훨씬 더 좋게 만들기 위해 원래 만들어졌다고 생각하는 매우 가벼운 웹 프레임워크입니다. 하지만 그들은 또한 매우 인기를 얻어서 더 이상 Cloudflare Worker만의 것이 아닙니다. 사람들은 실제로 Hono 위에 풀 스택 프레임워크를 구축하고 있습니다. 그들은 서버 측 렌더링을 하고 있고, 많은 멋진 일들을 하고 있습니다. 하지만 저는 거의 독점적으로 API, 즉 내부 서비스 대면 또는 서비스 간 통신을 위한 REST API를 구축하는 데 사용하거나, 경우에 따라 외부 대면으로 구축하기도 합니다.

[00:01:36.842 --> 00:01:55.602] 따라서 애플리케이션 사용자는 API를 제품으로 소비하고 있습니다. 따라서 Hono는 이러한 모든 다양한 사용 사례를 실제로 수행할 수 있으며 통합 프로세스는 정말 쉽습니다.

[00:01:55.602 --> 00:02:17.982] 이제 Hono를 통합하기 위한 문서를 보면, Cloudflare에 Hono 애플리케이션을 배포하는 방법을 살펴보면, 그들은 매우 구체적인 Hono 방식을 가지고 있을 것이고, 그 길을 완전히 따라갈 수 있습니다. 하지만 제가 좋아하는 방법은 기본적으로 Cloudflare 워커의 진입점이 이 코드 조각이라고 말하는 것입니다. 그리고 이 위에 제가 구축하는 모든 것은 더 수동적인 방식으로 연결될 것입니다.

[00:02:18.142 --> 00:02:25.490] 따라서 Hono가 설치되었는지 확인하기만 하면 됩니다. 이 프로젝트에 이미 설치되어 있어야 하지만, 확인을 위해 'pnpm i hono'를 실행할 수 있습니다.

[00:02:26.176 --> 00:02:27.616] 이제 설치되었습니다.

[00:02:28.336 --> 00:02:49.606] 이제 Source 내부에 새 폴더를 만들고 이름을 Hono라고 지정하겠습니다. 이것을 API라고 부를 수도 있겠지만, 이것은 REST API뿐만 아니라 다른 몇 가지 사용 사례도 있을 것이기 때문에 Hono라고 부르겠습니다. 매우 설명적으로요. 그런 다음 Hono 내부에 app.ts를 만들겠습니다.

[00:02:51.501 --> 00:02:56.446] 이제 app.ts 내부에서, 당연히 Hono를 가져오고 싶을 것이므로, 그렇게 하겠습니다.

[00:02:57.836 --> 00:03:05.116] 그런 다음 실제 Hono 앱을 설정할 것입니다. Hono 앱. 이것이 일반적인 구성입니다.

[00:03:05.934 --> 00:03:27.798] 많은 예제에서는 'const app = new Hono()'와 같이 표시될 것입니다. 그리고 여기에서 바인딩을 보지 못할 수도 있는데, 괜찮습니다. 이것은 유효한 설정입니다. 하지만 우리에게는 이것이 워커 진입점에서 사용할 수 있도록 내보내졌는지 확인하고, 바인딩이 Cloudflare의 EMV 바인딩이 될 것이라고 말할 것입니다. 그래서,

[00:03:28.219 --> 00:03:35.099] 이것이 애플리케이션의 기본 설정과 같습니다. 그리고 여기에서 실제 라우트를 구축할 수 있습니다.

[00:03:35.339 --> 00:03:47.534] 그래서 우리가 만들 첫 번째 라우트는 기본적으로 'app.get'이라고 말하고 콜론 ID라고 말한 다음 핸들러의 이 섹션 내에서 요청을 실제로 처리할 수 있게 될 것입니다.

[00:03:47.534 --> 00:03:57.904] 여기서 일어나는 일은 기본적으로 동적인 경로이며, 주어진 링크의 ID가 라우팅될 곳입니다.

[00:03:58.064 --> 00:04:12.834] 따라서 대시보드에서 링크를 만들 때, 그것은 일종의 무작위 ID이며, 클릭하면 이 엔드포인트에 도달해야 합니다. 그러면 저희 서비스가 이 ID를 가져와서 모든 라우팅 구성을 조회할 수 있게 됩니다.

[00:04:12.914 --> 00:04:20.014] 따라서 이 컨텍스트에는 몇 가지 다른 점이 있다는 것을 알게 될 것입니다. C는 Hono의 컨텍스트를 의미합니다.

[00:04:20.594 --> 00:04:44.094] 그리고 우리는 바인딩이 있는 EMV에 접근할 수 있습니다. 우리는 또한 요청에 접근할 수 있습니다. 이것은 실제로 이루어지고 있는 요청과 같습니다. 이것은 헤더와 쿠키 등을 포함할 것입니다. 우리는 또한 응답에 접근할 수 있습니다. 따라서 클라이언트 측에 저장되는 쿠키를 설정하려면 응답으로도 그렇게 할 수 있습니다. 그리고

[00:04:44.414 --> 00:04:56.794] 몇 가지 다른 것들이 있습니다. 예를 들어, C JSON이라고 말하고 싶다면, 기본적으로 'return c.json({ data: "hello world" })'라고 말할 수 있습니다.

[00:04:56.794 --> 00:05:13.974] 그래서 일단은 이것부터 시작하겠습니다. 따라서 Hono의 컨텍스트는 정말 강력합니다. 이것이 작동하도록 하기 위해 많은 것을 가져올 필요가 없다는 것을 알 수 있습니다. 우리는 단지 매우 기본적인 핸들러를 가지고 있으며, 'hello world'의 JSON 객체를 반환한다고 말합니다. 그리고 앞으로 이것을 더 확장할 것입니다.

[00:05:14.134 --> 00:05:25.296] 하지만 우리가 하고 싶은 것은 우리의 index.ts로 돌아가서 우리의 페치 핸들러가 더 이상 'hello world'를 반환하지 않도록 하는 것입니다.

[00:05:25.296 --> 00:05:39.826] 그것이 할 일은 앱을 반환하는 것이고, 우리는 그것을 Hono에서 가져올 것입니다. 그리고 Hono 인스턴스에는 페치 핸들러가 있을 것입니다. 그래서 그것은 요청을 통과시키는 일종의 패스스루 페치 핸들러가 될 것입니다.

[00:05:40.466 --> 00:05:53.626] 이제 이것이 우리가 통과시킬 전부는 아닙니다. 서비스, 워커 진입점은 환경에도 접근할 수 있습니다. 이것이 우리의 바인딩입니다. 또한 컨텍스트에도 접근할 수 있습니다.

[00:05:54.026 --> 00:06:14.936] 이제 이것은 Cloudflare 관련 항목을 반환합니다. 예를 들어, 요청이 수신된 후 실행될 수 있는 코드 조각을 전달할 수 있는 'waitUntil' 메서드가 있습니다. 따라서 실행하고 싶은 백그라운드 작업이 몇 초밖에 걸리지 않는 경우, 이것은 훌륭한 방법이며, 다음 몇 개의 비디오에서 실제로 이것을 사용할 것입니다.

[00:06:14.936 --> 00:06:29.936] 하지만 지금은 페치 핸들러가 실제로 몇 가지 추가 항목을 받는다는 것을 알 수 있습니다. 요청, 환경 변수 및 실행 컨텍스트를 받습니다. 따라서 이러한 것들을 전달할 것입니다. 따라서 이 EMV와 이 컨텍스트를 말할 것입니다.

[00:06:29.936 --> 00:06:43.506] 그리고 Hono가 표준 웹 요청과 함께 작동하지만 Cloudflare 런타임의 특정 미묘한 차이와도 완벽하게 작동하는 엄청나게 훌륭한 인터페이스를 만들었기 때문에 이 모든 것이 유형 안전하다는 것을 알 수 있습니다.

[00:06:43.586 --> 00:06:55.056] 여기서부터는 매우 간단한 패스스루입니다. 워커 진입점의 페치 핸들러는 Hono 애플리케이션의 페치 핸들러로 전달하기만 합니다.

[00:06:55.056 --> 00:07:05.748] 이제 'pnpm run dev'를 실행하면 이것이 시작되어야 하고, 홈페이지가 구축되지 않았기 때문에 이 Hono, 이 'hello world'는 찾을 수 없어야 합니다.

[00:07:06.278 --> 00:07:15.358] 하지만 아무 종류의 임의의 ID를 입력하면, 실제로 'hello, world' JSON 응답을 받는 것을 알 수 있습니다.

[00:07:15.998 --> 00:07:17.728] 이것이 Hono를 설정하는 방법입니다.

[00:07:17.888 --> 00:07:58.988] 매우, 매우 간단합니다. 아시다시피, 이것을 하는 방법에 대한 많은 글을 읽거나, 동영상을 보거나, 문서를 살펴볼 것입니다. 하지만 이것을 실제로 작동시키기 위해 작성해야 했던 코드의 양이 적다는 것은 정말 대단합니다. 아시다시피, 매우 간단한 Hono 앱 생성, 라우트 정의. 그리고 원하는 만큼 많은 라우트를 정의할 수 있습니다. 그리고 이것을 나눌 수도 있습니다. 따라서 애플리케이션이 정말 큰 API인 경우, 여러 Hono 인스턴스를 만드는 폴더를 만들고, 그 모든 인스턴스가 동일한 라우트에 연결되도록 할 수 있습니다. 그것은, 문서에 그것을 하는 방법에 대한 정보가 많이 있지만, 우리가 구축하고 있는 것은 매우 견고한 프레임워크입니다. 그리고 그것을 위한 통합 또한 고통스러울 정도로 간단합니다.

[00:07:58.988 --> 00:08:06.688] 요청을 페치 핸들러로 전달하고, 환경과 컨텍스트를 포함하도록 하는 것뿐입니다.

[00:08:06.688 --> 00:08:16.978] 특히 환경을 포함하지 않으면, Hono 애플리케이션 내에서 바인딩에 실제로 접근하려고 할 때 컨텍스트가 더 이상 해당 바인딩에 접근할 수 없기 때문에 오류가 발생할 것입니다.

[00:08:17.458 --> 00:08:25.862] 여기서 이번 강의는 마치겠습니다. 다음에는 동적 라우팅 로직을 실제로 처리하도록 이것을 확장할 것입니다.